<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Análise Comparativa de Tabelas Hash</title>
  <meta name="description" content="Implementação e análise comparativa de soluções baseadas em hashing (C++17): listas encadeadas vs endereçamento aberto; funções hash: divisão e multiplicação." />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <style>
    :root { --bg:#0b1220; --card:#111a2e; --muted:#a9b4c9; --text:#eaf0ff; --acc:#4da3ff; --acc2:#22c55e; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0c1426 40%,#0b1323);color:var(--text);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    a{color:var(--acc);text-decoration:none}
    header{position:sticky;top:0;z-index:10;background:rgba(11,18,32,.8);backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid #1e2a44}
    .nav{max-width:1100px;margin:auto;display:flex;gap:16px;align-items:center;justify-content:space-between;padding:10px 16px}
    .brand{display:flex;gap:10px;align-items:center}
    .brand h1{font-size:18px;margin:0}
    .menu{display:flex;gap:14px;flex-wrap:wrap}
    .container{max-width:1100px;margin:auto;padding:24px 16px}
    h2{margin:22px 0 10px;font-size:26px}
    h3{margin:18px 0 8px;font-size:20px;color:#cfe3ff}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
    .card{background:var(--card);border:1px solid #203052;border-radius:12px;padding:16px}
    .muted{color:var(--muted)}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #28436a;background:#0e1a31;color:#cde0ff;font-size:12px}
    .btn{display:inline-flex;align-items:center;gap:8px;background:linear-gradient(90deg,#2563eb,#0ea5e9);border:none;padding:10px 14px;border-radius:10px;color:#fff;font-weight:600}
    .twocol{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media (max-width:900px){.twocol{grid-template-columns:1fr}}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid #1f2b46}
    th{color:#cde0ff;text-align:left}
    tr:hover{background:#0f1a34}
    .footer{border-top:1px solid #1e2a44;margin-top:28px;padding-top:16px;color:#9db0d4}
    pre{background:#0d162b;border:1px solid #1d2a49;border-radius:10px;padding:14px;overflow:auto}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .chart{height:340px}
    .tag{display:inline-block;margin:2px 6px 0 0;padding:4px 8px;border:1px solid #28436a;border-radius:999px;color:#bcd5ff;font-size:12px}
    /* Prism theme tweaks */
    .token.comment{color:#94a3b8}
    .token.keyword{color:#93c5fd}
    .token.string{color:#86efac}
    .token.function{color:#fca5a5}
    .token.number{color:#fcd34d}
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <header>
    <div class="nav">
      <div class="brand">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none"><path d="M4 6h16M4 12h10M4 18h16" stroke="#9cc6ff" stroke-width="2" stroke-linecap="round"/></svg>
        <h1>Análise Comparativa de Tabelas Hash</h1>
      </div>
      <nav class="menu">
        <a href="#intro">Introdução</a>
        <a href="#metodologia">Metodologia</a>
        <a href="#implementacao">Implementação</a>
        <a href="#resultados">Resultados</a>
        <a href="#discussao">Discussão</a>
        <a href="#conclusao">Conclusão</a>
        <a href="https://github.com/Gabriel-Freitas-S/analise_hash" target="_blank" rel="noopener">Repositório</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <section id="intro" class="card">
      <div class="twocol">
        <div>
          <h2>Introdução</h2>
          <p>Este trabalho implementa e compara duas estratégias de tratamento de colisões em tabelas hash — <b>listas encadeadas</b> (chaining) e <b>endereçamento aberto</b> (sondagem linear) — aliadas a duas funções de hashing: <b>divisão</b> e <b>multiplicação</b>. O estudo quantifica <b>tempo de inserção</b>, <b>tempo de busca</b>, <b>colisões</b> e <b>fator de carga</b> com datasets de 100 a 50.000 elementos, em C++17.</p>
          <div>
            <span class="tag">C++17</span>
            <span class="tag">Encadeamento</span>
            <span class="tag">Endereçamento Aberto</span>
            <span class="tag">Divisão</span>
            <span class="tag">Multiplicação</span>
            <span class="tag">Benchmarks</span>
          </div>
        </div>
        <div class="card">
          <h3>Funções Hash</h3>
          <p class="muted"><b>Divisão:</b> h(k) = k mod p. &nbsp; <b>Multiplicação:</b> h(k) = ⌊ frac(k×c) × p ⌋, com c ≈ 0,618.</p>
          <p class="muted">Para encadeamento, tamanhos <i>primos</i> (29, 97, 251, 499, 911) favorecem distribuição; para aberto, tabela fixa 50.009.</p>
        </div>
      </div>
    </section>

    <section id="metodologia" class="card">
      <h2>Metodologia</h2>
      <p>Os experimentos inserem e buscam inteiros provenientes de arquivos de dados, medindo tempos com relógio de alta resolução. Para cada dataset, testamos <b>encadeamento</b> com cinco tamanhos de tabela e <b>endereçamento aberto</b> com tamanho fixo. Os arquivos de 100 a 50.000 elementos foram usados, e 1.000 números aleatórios (com repetição) serviram para as buscas.</p>
      <ul>
        <li><b>Métricas:</b> Tempo de Inserção (ms), Tempo de Busca (ms), Colisões, Fator de Carga.</li>
        <li><b>Dados:</b> resultados_benchmark.csv gerado pelo programa.</li>
      </ul>
    </section>

    <section id="implementacao" class="card">
      <h2>Implementação</h2>
      <h3>Estrutura do Projeto</h3>
      <pre><code class="language-bash">analise_hash/
├── include/
│   ├── TabelaHashEncadeada.hpp
│   ├── TabelaHashAberta.hpp
│   └── GeradorDados.hpp
├── src/
│   ├── main.cpp
│   ├── TabelaHashEncadeada.cpp
│   ├── TabelaHashAberta.cpp
│   └── GeradorDados.cpp
├── data/
│   ├── numeros_aleatorios_100.txt
│   ├── numeros_aleatorios_500.txt
│   ├── numeros_aleatorios_1000.txt
│   ├── numeros_aleatorios_5000.txt
│   ├── numeros_aleatorios_10000.txt
│   └── numeros_aleatorios_50000.txt
├── resultados_benchmark.csv
├── CMakeLists.txt
└── README.md</code></pre>

      <h3>TabelaHashEncadeada.hpp/.cpp</h3>
      <p>Implementa uma tabela hash com <b>encadeamento</b> para resolução de colisões. Cada posição da tabela é uma lista ligada de nós. Pontos-chave:</p>
      <ul>
        <li><b>No</b>: nó da lista com valor e ponteiro único para o próximo.</li>
        <li><b>TipoHash</b>: enum para escolher <i>DIVISAO</i> ou <i>MULTIPLICACAO</i>.</li>
        <li><b>Inserir/Buscar/Remover</b>: evitam duplicatas e garantem O(1) médio.</li>
        <li><b>Estatísticas</b>: comprimento médio das listas, maior lista e colisões estimadas.</li>
      </ul>
      <pre><code class="language-cpp">// Hash por divisão (índice no intervalo [0, tamanho))
size_t calcularHashDivisao(int chave) const {
  return static_cast&lt;size_t&gt;(std::abs(chave)) % tamanho;
}
// Hash por multiplicação (fração áurea)
size_t calcularHashMultiplicacao(int chave) const {
  double prod = std::abs(chave) * 0.6180339887; // CONSTANTE_MULTIPLICACAO
  double frac = prod - std::floor(prod);
  return static_cast&lt;size_t&gt;(std::floor(frac * tamanho));
}</code></pre>

      <h3>TabelaHashAberta.hpp/.cpp</h3>
      <p>Implementa <b>endereçamento aberto</b> com <b>sondagem linear</b>, além de <i>lazy deletion</i>, controle de <i>fator de carga</i> e análise de <i>clustering</i>. O rehash é recomendado quando a carga ultrapassa limites definidos.</p>
      <pre><code class="language-cpp">// Sondagem linear: busca posição disponível ou o próprio valor
size_t sondagemLinear(size_t indiceInicial, int valor, bool paraInsercao) const {
  size_t tentativas = 0; size_t i = indiceInicial;
  while (tentativas &lt; tamanho) {
    const Celula &cel = tabela[i];
    if (paraInsercao) {
      if (cel.disponivelParaInsercao()) return i; // VAZIO ou REMOVIDO
      if (cel.estado == Celula::Estado::OCUPADO &amp;&amp; cel.valor == valor) return i; // duplicata
    } else {
      if (cel.estado == Celula::Estado::VAZIO) return tamanho; // não encontrado
      if (cel.estado == Celula::Estado::OCUPADO &amp;&amp; cel.valor == valor) return i; // encontrado
    }
    i = (i + 1) % tamanho; ++tentativas;
  }
  return tamanho; // não encontrou
}</code></pre>

      <h3>GeradorDados.hpp/.cpp</h3>
      <p>Responsável por <b>carregar</b> datasets de <code>data/</code>, <b>gerar</b> números (com/sem repetição), <b>validar</b> arquivos, calcular <b>estatísticas</b> e salvar relatórios. Também gera os insumos para benchmarks.</p>
      <pre><code class="language-cpp">// Carrega números de um arquivo com cabeçalho de quantidade
std::vector&lt;int&gt; carregarDeArquivo(const std::string &nomeArquivo);
// Gera N números aleatórios únicos
std::vector&lt;int&gt; gerarNumerosAleatorios(size_t quantidade);
// Gera N números aleatórios com possíveis repetições
std::vector&lt;int&gt; gerarNumerosAleatoriosComRepeticao(size_t quantidade);</code></pre>

      <h3>main.cpp</h3>
      <p>Orquestra os experimentos: carrega datasets, executa inserções/buscas nas tabelas, mede tempos, estima colisões e salva o <code>resultados_benchmark.csv</code>. Também imprime um relatório no console.</p>
      <pre><code class="language-cpp">struct ResultadoTeste { /* ... métricas ... */ };
class BenchmarkManager {
  template&lt;typename Func&gt;
  double medirTempo(Func &amp;&amp;f) { /* high_resolution_clock */ }
  void testarTabelaEncadeada(...);
  void testarTabelaAberta(...);
  void salvarResultados(const std::string &arquivo);
};
int main() { /* carrega dados, roda testes e salva CSV */ }</code></pre>
    </section>

    <section id="resultados" class="card">
      <h2>Resultados</h2>
      <div class="grid">
        <div class="card" style="grid-column: span 12;">
          <h3>Comparação de Tempo de Inserção</h3>
          <canvas id="g_insercao" class="chart"></canvas>
        </div>
        <div class="card" style="grid-column: span 12;">
          <h3>Comparação de Tempo de Busca</h3>
          <canvas id="g_busca" class="chart"></canvas>
        </div>
        <div class="card" style="grid-column: span 12;">
          <h3>Comparação de Funções Hash (Inserção)</h3>
          <canvas id="g_funcoes" class="chart"></canvas>
        </div>
        <div class="card" style="grid-column: span 12;">
          <h3>Relação Fator de Carga × Colisões</h3>
          <canvas id="g_carga_colisao" class="chart"></canvas>
        </div>
      </div>
      <p class="muted">Fontes: dados empíricos do arquivo <code>resultados_benchmark.csv</code> gerado pela aplicação.</p>
    </section>

    <section id="discussao" class="card">
      <h2>Discussão</h2>
      <p><b>Encadeamento</b> apresenta estabilidade mesmo com alto fator de carga, à custa de memória adicional por listas. <b>Endereçamento aberto</b> é eficiente em espaço, mas sofre com <i>clustering</i> e degrada com fatores de carga elevados, exigindo rehash. A função de <b>divisão</b> tendeu a ser mais rápida nos testes, enquanto a de <b>multiplicação</b> pode oferecer distribuição mais uniforme conforme o tamanho da tabela.</p>
    </section>

    <section id="conclusao" class="card">
      <h2>Conclusão</h2>
      <p>As duas estratégias são viáveis: para cargas altas e inserções intensivas, o encadeamento manteve tempos competitivos e previsíveis; para economia de espaço e consultas rápidas em baixas cargas, o endereçamento aberto se mostrou atrativo. Controlar o <b>fator de carga</b> é determinante para a performance, especialmente em endereçamento aberto. A escolha ótima depende do perfil de uso, da política de rehash e do tamanho da tabela.</p>
      <a class="btn" href="https://github.com/Gabriel-Freitas-S/analise_hash" target="_blank" rel="noopener">Ver Repositório</a>
    </section>

    <div class="footer">
      <p>Autores: <a href="https://github.com/Gabriel-Freitas-S" target="_blank">Gabriel Freitas Souza</a> e <a href="https://github.com/RoberliSchuina" target="_blank">Roberli Schuina Silva</a> • Disciplina: Pesquisa e Ordenação • C++17</p>
    </div>
  </main>

  <script>
  // Fallback: inclui CSV inline para GitHub Pages quando o fetch falhar (ex: navegador bloqueia path relativo)
  const CSV_INLINE = `TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga
Encadeada,29,100,Divisao,0.010,0.018,71,3.4483
Encadeada,29,100,Multiplicacao,0.009,0.028,71,3.4483
Encadeada,97,100,Divisao,0.008,0.014,37,1.0309
Encadeada,97,100,Multiplicacao,0.008,0.023,37,1.0309
Encadeada,251,100,Divisao,0.006,0.014,0,0.3984
Encadeada,251,100,Multiplicacao,0.005,0.013,0,0.3984
Encadeada,499,100,Divisao,0.009,0.007,0,0.2004
Encadeada,499,100,Multiplicacao,0.006,0.012,0,0.2004
Encadeada,911,100,Divisao,0.007,0.005,0,0.1098
Encadeada,911,100,Multiplicacao,0.006,0.010,0,0.1098
Aberta,50009,100,Divisao,0.012,0.005,0,0.0020
Aberta,50009,100,Multiplicacao,0.001,0.007,0,0.0020
Encadeada,29,500,Divisao,0.044,0.035,470,17.2069
Encadeada,29,500,Multiplicacao,0.051,0.048,470,17.2069
Encadeada,97,500,Divisao,0.060,0.031,402,5.1443
Encadeada,97,500,Multiplicacao,0.060,0.047,402,5.1443
Encadeada,251,500,Divisao,0.027,0.013,282,1.9880
Encadeada,251,500,Multiplicacao,0.041,0.023,282,1.9880
Encadeada,499,500,Divisao,0.026,0.011,0,1.0000
Encadeada,499,500,Multiplicacao,0.026,0.019,0,1.0000
Encadeada,911,500,Divisao,0.029,0.010,0,0.5477
Encadeada,911,500,Multiplicacao,0.030,0.016,0,0.5477
Aberta,50009,499,Divisao,0.004,0.004,2,0.0100
Aberta,50009,499,Multiplicacao,0.007,0.009,2,0.0100
Encadeada,29,1000,Divisao,0.099,0.054,971,34.4828
Encadeada,29,1000,Multiplicacao,0.077,0.070,971,34.4828
Encadeada,97,1000,Divisao,0.070,0.030,903,10.3093
Encadeada,97,1000,Multiplicacao,0.101,0.045,903,10.3093
Encadeada,251,1000,Divisao,0.063,0.017,753,3.9841
Encadeada,251,1000,Multiplicacao,0.067,0.025,753,3.9841
Encadeada,499,1000,Divisao,0.065,0.016,568,2.0040
Encadeada,499,1000,Multiplicacao,0.080,0.034,568,2.0040
Encadeada,911,1000,Divisao,0.039,0.011,392,1.0977
Encadeada,911,1000,Multiplicacao,0.046,0.021,392,1.0977
Aberta,50009,1000,Divisao,0.004,0.002,9,0.0200
Aberta,50009,1000,Multiplicacao,0.015,0.005,9,0.0200
Encadeada,29,5000,Divisao,1.996,0.782,4958,171.9655
Encadeada,29,5000,Multiplicacao,1.802,0.709,4958,171.9655
Encadeada,97,5000,Divisao,0.757,0.252,4890,51.4124
Encadeada,97,5000,Multiplicacao,0.780,0.228,4890,51.4124
Encadeada,251,5000,Divisao,0.446,0.076,4736,19.8685
Encadeada,251,5000,Multiplicacao,0.501,0.084,4736,19.8685
Encadeada,499,5000,Divisao,0.360,0.039,4488,9.9940
Encadeada,499,5000,Multiplicacao,0.422,0.050,4488,9.9940
Encadeada,911,5000,Divisao,0.311,0.027,4079,5.4742
Encadeada,911,5000,Multiplicacao,0.351,0.042,4079,5.4742
Aberta,50009,4987,Divisao,0.050,0.005,248,0.0997
Aberta,50009,4987,Multiplicacao,0.164,0.013,248,0.0997
Encadeada,29,10000,Divisao,10.647,1.779,9922,343.1379
Encadeada,29,10000,Multiplicacao,9.404,1.932,9922,343.1379
Encadeada,97,10000,Divisao,3.794,1.424,9854,102.5876
Encadeada,97,10000,Multiplicacao,3.483,0.541,9854,102.5876
Encadeada,251,10000,Divisao,1.358,0.195,9700,39.6454
Encadeada,251,10000,Multiplicacao,1.445,0.205,9700,39.6454
Encadeada,499,10000,Divisao,0.896,0.080,9452,19.9419
Encadeada,499,10000,Multiplicacao,0.931,0.078,9452,19.9419
Encadeada,911,10000,Divisao,0.647,0.038,9040,10.9232
Encadeada,911,10000,Multiplicacao,0.978,0.048,9040,10.9232
Aberta,50009,9951,Divisao,0.054,0.006,990,0.1990
Aberta,50009,9951,Multiplicacao,0.087,0.009,990,0.1990
Encadeada,29,50000,Divisao,249.355,10.696,48723,1681.1034
Encadeada,29,50000,Multiplicacao,216.560,10.778,48723,1681.1034
Encadeada,97,50000,Divisao,73.418,3.616,48655,502.5979
Encadeada,97,50000,Multiplicacao,75.745,3.505,48655,502.5979
Encadeada,251,50000,Divisao,33.389,2.266,48501,194.2311
Encadeada,251,50000,Multiplicacao,37.609,1.819,48501,194.2311
Encadeada,499,50000,Divisao,19.196,0.810,48253,97.6994
Encadeada,499,50000,Multiplicacao,20.494,0.681,48253,97.6994
Encadeada,911,50000,Divisao,11.557,0.389,47841,53.5148
Encadeada,911,50000,Multiplicacao,11.549,0.468,47841,53.5148
Aberta,50009,25005,Divisao,0.324,0.016,6251,0.5000
Aberta,50009,25005,Multiplicacao,0.355,0.024,6251,0.5000`;

  async function carregarCSV(){
    try {
      const resp = await fetch('resultados_benchmark.csv', {cache:'no-store'});
      if (!resp.ok) throw new Error('fetch falhou');
      const text = await resp.text();
      if (!text || text.indexOf('TipoTabela') !== 0) throw new Error('conteúdo inesperado');
      return parseCSV(text);
    } catch (e) {
      // fallback para inline CSV em páginas estáticas
      return parseCSV(CSV_INLINE);
    }
  }
  function parseCSV(text){
    const linhas = text.trim().split(/\r?\n/); linhas.shift();
    return linhas.map(l => {
      const c = l.split(',');
      return { TipoTabela:c[0], TamanhoTabela:+c[1], QuantidadeDados:+c[2], FuncaoHash:c[3],
               TempoInsercao:+c[4], TempoBusca:+c[5], Colisoes:+c[6], FatorCarga:+c[7] };
    });
  }

  function criarGraficoLinha(ctx, titulo, labelX, labelY, series){
    new Chart(ctx, { type: 'line', data: { labels: series[0].x, datasets: series.map(s => ({
        label: s.nome, data: s.y, borderColor: s.cor, backgroundColor: s.cor+'33', tension:.2, fill:false }))},
      options: { responsive:true, maintainAspectRatio:false,
        plugins:{ legend:{labels:{color:'#dbeafe'}}, title:{display:true,text:titulo,color:'#eaf0ff'}, tooltip:{callbacks:{label:(ctx)=>`${ctx.dataset.label}: ${ctx.parsed.y} ms`}} },
        scales:{ x:{ title:{display:true,text:labelX,color:'#cfe3ff'}, ticks:{color:'#cfe3ff'} }, y:{ title:{display:true,text:labelY,color:'#cfe3ff'}, ticks:{color:'#cfe3ff'} } } } });
  }
  function criarGraficoBarras(ctx, titulo, labelX, labelY, categorias, valores1, valores2, nome1, nome2){
    new Chart(ctx, { type:'bar', data:{ labels: categorias, datasets:[
        {label:nome1, data: valores1, backgroundColor:'#60a5fa'},
        {label:nome2, data: valores2, backgroundColor:'#34d399'} ]},
      options:{ responsive:true, maintainAspectRatio:false,
        plugins:{ legend:{labels:{color:'#dbeafe'}}, title:{display:true,text:titulo,color:'#eaf0ff'}, tooltip:{callbacks:{label:(ctx)=>`${ctx.dataset.label}: ${ctx.parsed.y} ms`}}},
        scales:{ x:{ title:{display:true,text:labelX,color:'#cfe3ff'}, ticks:{color:'#cfe3ff'} }, y:{ title:{display:true,text:labelY,color:'#cfe3ff'}, ticks:{color:'#cfe3ff'} } } } });
  }
  function criarGraficoDispersao(ctx, titulo, labelX, labelY, pontos){
    new Chart(ctx, { type:'scatter', data:{ datasets:[{ label:'Encadeada', data: pontos, backgroundColor:'#f59e0b' }]},
      options:{ responsive:true, maintainAspectRatio:false,
        plugins:{ legend:{labels:{color:'#dbeafe'}}, title:{display:true,text:titulo,color:'#eaf0ff'}, tooltip:{callbacks:{label:(ctx)=>`Fator de Carga: ${ctx.parsed.x}, Colisões: ${ctx.parsed.y}`}}},
        scales:{ x:{ title:{display:true,text:labelX,color:'#cfe3ff'}, ticks:{color:'#cfe3ff'} }, y:{ title:{display:true,text:labelY,color:'#cfe3ff'}, ticks:{color:'#cfe3ff'} } } } });
  }

  (async ()=>{
    const dados = await carregarCSV();

    // Inserção — linhas agregadas por QuantidadeDados
    const gruposQD = [...new Set(dados.map(d=>d.QuantidadeDados))].sort((a,b)=>a-b);
    const serieIns = tipo => gruposQD.map(q => {
      const subset = dados.filter(d=>d.QuantidadeDados===q && d.TipoTabela===tipo);
      const media = subset.length ? subset.reduce((s,x)=>s+x.TempoInsercao,0)/subset.length : 0;
      return +media.toFixed(3);
    });
    criarGraficoLinha(
      document.getElementById('g_insercao'),
      'Comparação de Tempo de Inserção','Quantidade de Dados','Tempo de Inserção (ms)',
      [ {nome:'Tabela Encadeada', x:gruposQD, y:serieIns('Encadeada'), cor:'#60a5fa'},
        {nome:'Tabela Aberta',    x:gruposQD, y:serieIns('Aberta'),    cor:'#34d399'} ]
    );

    // Busca — linhas agregadas
    const serieBus = tipo => gruposQD.map(q => {
      const subset = dados.filter(d=>d.QuantidadeDados===q && d.TipoTabela===tipo);
      const media = subset.length ? subset.reduce((s,x)=>s+x.TempoBusca,0)/subset.length : 0;
      return +media.toFixed(3);
    });
    criarGraficoLinha(
      document.getElementById('g_busca'),
      'Comparação de Tempo de Busca','Quantidade de Dados','Tempo de Busca (ms)',
      [ {nome:'Tabela Encadeada', x:gruposQD, y:serieBus('Encadeada'), cor:'#06b6d4'},
        {nome:'Tabela Aberta',    x:gruposQD, y:serieBus('Aberta'),    cor:'#a78bfa'} ]
    );

    // Funções hash — barras @ 10.000 elementos (Encadeada)
    const alvo = 10000; const tamanhos = [29,97,251,499,911];
    const enc10k = dados.filter(d=>d.TipoTabela==='Encadeada' && d.QuantidadeDados===alvo);
    const divs = tamanhos.map(t=> +(enc10k.find(d=>d.TamanhoTabela===t && d.FuncaoHash==='Divisao')?.TempoInsercao ?? 0).toFixed(3));
    const mult = tamanhos.map(t=> +(enc10k.find(d=>d.TamanhoTabela===t && d.FuncaoHash==='Multiplicacao')?.TempoInsercao ?? 0).toFixed(3));
    criarGraficoBarras(
      document.getElementById('g_funcoes'),
      'Comparação de Funções Hash (Inserção)','Tamanho da Tabela','Tempo de Inserção (ms)',
      tamanhos.map(String), divs, mult, 'Função Divisão', 'Função Multiplicação'
    );

    // Dispersão — Fator de Carga × Colisões (Encadeada)
    const pontos = dados.filter(d=>d.TipoTabela==='Encadeada').map(d=>({x:+d.FatorCarga.toFixed(4), y:d.Colisoes}));
    criarGraficoDispersao(
      document.getElementById('g_carga_colisao'),
      'Relação Fator de Carga × Colisões','Fator de Carga','Número de Colisões',
      pontos
    );
  })();
  </script>
</body>
</html>
