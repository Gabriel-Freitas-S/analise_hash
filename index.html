<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabalho 2: An√°lise de Tabela Hash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
        }
        .code-block .keyword { color: #93c5fd; } /* blue-300 */
        .code-block .type { color: #6ee7b7; } /* emerald-300 */
        .code-block .comment { color: #6b7280; } /* gray-500 */
        .code-block .string { color: #fde047; } /* yellow-300 */
        .code-block .number { color: #f9a8d4; } /* pink-300 */
        .code-block .preprocessor { color: #d8b4fe; } /* purple-300 */
        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
        }
        details > summary {
            cursor: pointer;
            font-weight: 600;
            padding: 0.75rem 1rem;
            background-color: #f3f4f6; /* gray-100 */
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        details > summary:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        details[open] > summary {
            background-color: #e5e7eb; /* gray-200 */
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details > summary::after {
            content: '‚ñº';
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        details[open] > summary::after {
            transform: rotate(180deg);
        }
        .details-content {
            padding: 1.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header -->
    <header class="bg-white shadow-md">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-3xl font-bold text-gray-900">An√°lise Comparativa de Solu√ß√µes Baseadas em Hashing</h1>
            <p class="text-lg text-gray-600 mt-1">Disciplina: Pesquisa e Ordena√ß√£o</p>
        </div>
    </header>

    <main class="container mx-auto px-6 py-8">
        
        <!-- Se√ß√£o de Introdu√ß√£o -->
        <section id="introducao" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">1. Introdu√ß√£o</h2>
            <p class="text-gray-700 leading-relaxed">
                O hashing √© uma t√©cnica fundamental em ci√™ncia da computa√ß√£o, usada para armazenar e recuperar dados de forma eficiente. A efic√°cia de um sistema de hashing depende crucialmente da fun√ß√£o de hash e da estrat√©gia de tratamento de colis√µes. Este trabalho implementa e analisa comparativamente duas solu√ß√µes de hashing: <strong>Tabela Hash com Endere√ßamento Aberto</strong> e <strong>Tabela Hash com Encadeamento Separado</strong>.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                A an√°lise explora duas fun√ß√µes de hashing distintas ‚Äî uma baseada em divis√£o e outra em multiplica√ß√£o ‚Äî para avaliar o desempenho de cada abordagem em diferentes cen√°rios de carga de dados e tamanho da tabela. O objetivo √© identificar as vantagens, desvantagens e os comportamentos espec√≠ficos de cada combina√ß√£o, fornecendo uma vis√£o clara sobre sua aplicabilidade pr√°tica.
            </p>
        </section>

        <!-- Estrutura do Projeto -->
        <section id="estrutura" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">2. Estrutura do Projeto</h2>
            <p class="mb-4 text-gray-700">O projeto foi organizado de forma modular para separar as defini√ß√µes das classes, suas implementa√ß√µes e os dados de teste. A estrutura atual reflete nomes mais claros e apropriados para cada componente.</p>
            <div class="code-block">
                <pre>
/
‚îú‚îÄ‚îÄ CMakeLists.txt              <span class="comment">// Arquivo de configura√ß√£o do build com CMake</span>
‚îú‚îÄ‚îÄ data/                        <span class="comment">// Diret√≥rio para os conjuntos de dados de entrada</span>
‚îÇ   ‚îú‚îÄ‚îÄ numeros_aleatorios_100.txt
‚îÇ   ‚îú‚îÄ‚îÄ numeros_aleatorios_500.txt
‚îÇ   ‚îú‚îÄ‚îÄ numeros_aleatorios_1000.txt
‚îÇ   ‚îú‚îÄ‚îÄ numeros_aleatorios_5000.txt
‚îÇ   ‚îú‚îÄ‚îÄ numeros_aleatorios_10000.txt
‚îÇ   ‚îî‚îÄ‚îÄ numeros_aleatorios_50000.txt
‚îú‚îÄ‚îÄ include/                     <span class="comment">// Arquivos de cabe√ßalho (.hpp) com as defini√ß√µes das classes</span>
‚îÇ   ‚îú‚îÄ‚îÄ CarregadorDados.hpp       <span class="comment">// Carregamento de datasets da pasta data/</span>
‚îÇ   ‚îú‚îÄ‚îÄ TabelaEncadeada.hpp       <span class="comment">// Tabela hash com encadeamento</span>
‚îÇ   ‚îî‚îÄ‚îÄ TabelaAberta.hpp          <span class="comment">// Tabela hash com endere√ßamento aberto</span>
‚îú‚îÄ‚îÄ src/                         <span class="comment">// Arquivos de c√≥digo-fonte (.cpp) com as implementa√ß√µes</span>
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp                  <span class="comment">// Ponto de entrada, orquestra os benchmarks</span>
‚îÇ   ‚îú‚îÄ‚îÄ CarregadorDados.cpp       <span class="comment">// Implementa√ß√£o do carregador</span>
‚îÇ   ‚îú‚îÄ‚îÄ TabelaEncadeada.cpp       <span class="comment">// Implementa√ß√£o do encadeamento</span>
‚îÇ   ‚îî‚îÄ‚îÄ TabelaAberta.cpp          <span class="comment">// Implementa√ß√£o do endere√ßamento aberto</span>
‚îú‚îÄ‚îÄ index.html                   <span class="comment">// P√°gina web com an√°lise completa</span>
‚îî‚îÄ‚îÄ resultados_benchmark.csv     <span class="comment">// Arquivo de sa√≠da com os resultados dos testes</span>
                </pre>
            </div>
        </section>

        <!-- An√°lise do C√≥digo-Fonte -->
        <section id="codigo" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">3. An√°lise Detalhada do C√≥digo-Fonte</h2>
            <p class="text-gray-700 leading-relaxed mb-6">
                Esta se√ß√£o apresenta uma an√°lise t√©cnica detalhada de cada componente do projeto, explicando as decis√µes de design, algoritmos implementados e complexidades computacionais. Todos os arquivos foram desenvolvidos seguindo boas pr√°ticas de programa√ß√£o C++17 e incluem documenta√ß√£o profissional completa.
            </p>
            
            <div class="space-y-4">
                <!-- main.cpp -->
                <article>
                    <details>
                        <summary><code>src/main.cpp</code> - Programa Principal e Orquestrador de Benchmarks</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìã Vis√£o Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                O arquivo <code>main.cpp</code> √© o cora√ß√£o do sistema de benchmarking, respons√°vel por coordenar todos os testes comparativos entre as diferentes implementa√ß√µes de tabelas hash. Implementa um framework robusto de medi√ß√£o de performance que executa testes sistem√°ticos e gera relat√≥rios detalhados.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üèóÔ∏è Arquitetura Principal</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>ResultadoTeste:</strong> Estrutura que encapsula todas as m√©tricas de um teste espec√≠fico (tempos, colis√µes, fator de carga)</li>
                                <li><strong>BenchmarkManager:</strong> Classe gerenciadora que coordena execu√ß√£o de testes, coleta de dados e gera√ß√£o de relat√≥rios</li>
                                <li><strong>Template medirTempo():</strong> Fun√ß√£o gen√©rica para medi√ß√£o precisa usando std::chrono::high_resolution_clock</li>
                                <li><strong>Algoritmos de estimativa:</strong> Fun√ß√µes matem√°ticas para calcular colis√µes esperadas baseadas em teoria probabil√≠stica</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">‚öôÔ∏è Funcionalidades T√©cnicas</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <h5 class="font-semibold mb-2">Medi√ß√£o de Performance</h5>
                                <p class="text-gray-700 text-sm mb-2">Utiliza std::chrono para medi√ß√µes em microssegundos, convertidas para milissegundos para legibilidade. O template permite medi√ß√£o de qualquer fun√ß√£o lambda.</p>
                                
                                <h5 class="font-semibold mb-2">Estimativa de Colis√µes</h5>
                                <p class="text-gray-700 text-sm mb-2"><strong>Encadeamento:</strong> Baseada na distribui√ß√£o de Poisson: colis√µes ‚âà n - m(1 - e^(-Œª)), onde Œª = n/m</p>
                                <p class="text-gray-700 text-sm"><strong>Endere√ßamento Aberto:</strong> Considera clustering prim√°rio: colis√µes ‚âà n √ó fc / 2</p>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üîÑ Fluxo de Execu√ß√£o</h4>
                            <ol class="list-decimal list-inside space-y-2 text-gray-700 mb-4">
                                <li>Inicializa√ß√£o de componentes (CarregadorDados, BenchmarkManager)</li>
                                <li>Gera√ß√£o de dataset para opera√ß√µes de busca (1000 n√∫meros aleat√≥rios)</li>
                                <li>Loop principal atrav√©s dos arquivos de dataset (100 a 50.000 elementos)</li>
                                <li>Para cada dataset: testa todas as configura√ß√µes de tabela encadeada e aberta</li>
                                <li>Medi√ß√£o precisa de tempos de inser√ß√£o e busca</li>
                                <li>C√°lculo de estat√≠sticas (colis√µes, fator de carga)</li>
                                <li>Gera√ß√£o de relat√≥rios (console + CSV)</li>
                            </ol>
                            
                            <div class="code-block"><pre><code><span class="comment">// Estrutura para encapsular resultados de teste</span>
<span class="keyword">struct</span> ResultadoTeste {
    <span class="type">std::string</span> tipoTabela;      <span class="comment">// "Encadeada" ou "Aberta"</span>
    <span class="type">size_t</span> tamanhoTabela;        <span class="comment">// Tamanho da tabela hash</span>
    <span class="type">size_t</span> quantidadeDados;      <span class="comment">// Elementos inseridos</span>
    <span class="type">std::string</span> tipoFuncaoHash;  <span class="comment">// "Divisao" ou "Multiplicacao"</span>
    <span class="type">double</span> tempoInsercao;        <span class="comment">// Tempo em milissegundos</span>
    <span class="type">double</span> tempoBusca;           <span class="comment">// Tempo em milissegundos</span>
    <span class="type">size_t</span> colisoes;             <span class="comment">// Estimativa de colis√µes</span>
    <span class="type">double</span> fatorCarga;           <span class="comment">// elementos/tamanho</span>
};

<span class="comment">// Template para medi√ß√£o precisa de tempo</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;
<span class="type">double</span> medirTempo(Func&amp;&amp; func) {
    <span class="keyword">auto</span> inicio = <span class="type">std::chrono::high_resolution_clock::now</span>();
    func();  <span class="comment">// Executa fun√ß√£o a ser medida</span>
    <span class="keyword">auto</span> fim = <span class="type">std::chrono::high_resolution_clock::now</span>();
    
    <span class="comment">// Converte para milissegundos com precis√£o decimal</span>
    <span class="keyword">auto</span> duracao = <span class="type">std::chrono::duration_cast&lt;std::chrono::microseconds&gt;</span>(fim - inicio);
    <span class="keyword">return</span> duracao.count() / <span class="number">1000.0</span>;
}</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìä Complexidade e Performance</h4>
                            <p class="text-gray-700 leading-relaxed">
                                <strong>Complexidade total:</strong> O(k √ó n √ó t) onde k = n√∫mero de datasets, n = tamanho m√©dio dos datasets, t = configura√ß√µes testadas. O programa √© otimizado para minimizar overhead de medi√ß√£o e utiliza tratamento robusto de exce√ß√µes para continuar execu√ß√£o mesmo com falhas individuais.
                            </p>
                        </div>
                    </details>
                </article>

                <!-- TabelaEncadeada.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaEncadeada.hpp</code> - Interface da Tabela Hash com Encadeamento</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìã Vis√£o Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Define a interface completa da implementa√ß√£o de tabela hash com encadeamento (separate chaining). Utiliza listas encadeadas com ponteiros inteligentes para garantir seguran√ßa de mem√≥ria e performance otimizada. Cada posi√ß√£o da tabela pode conter uma lista de elementos que colidiram no mesmo √≠ndice.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üèóÔ∏è Estruturas Principais</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <h5 class="font-semibold mb-2">Estrutura No</h5>
                                <p class="text-gray-700 text-sm mb-2">Representa um n√≥ da lista encadeada com std::unique_ptr para gerenciamento autom√°tico de mem√≥ria. Evita vazamentos e simplifica destrui√ß√£o.</p>
                                
                                <h5 class="font-semibold mb-2">Classe TabelaEncadeada</h5>
                                <p class="text-gray-700 text-sm mb-2">Cont√©m std::vector de unique_ptr para as listas, garantindo que cada posi√ß√£o possa ter uma lista independente de tamanho vari√°vel.</p>
                                
                                <h5 class="font-semibold mb-2">Enum TipoHash</h5>
                                <p class="text-gray-700 text-sm">Define os dois m√©todos de hashing: DIVISAO (k mod m) e MULTIPLICACAO (baseado na propor√ß√£o √°urea).</p>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">‚öôÔ∏è M√©todos Principais</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>inserir():</strong> Insere no in√≠cio da lista (O(1)) ap√≥s verificar duplicatas</li>
                                <li><strong>buscar():</strong> Percorre lista sequencialmente (O(1) m√©dio, O(n) pior caso)</li>
                                <li><strong>remover():</strong> Remove elemento e reconecta ponteiros (O(1) m√©dio)</li>
                                <li><strong>calcularHashDivisao():</strong> h(k) = |k| mod m (simples e eficiente)</li>
                                <li><strong>calcularHashMultiplicacao():</strong> h(k) = ‚åäm √ó ((k √ó A) mod 1)‚åã onde A = 0.618...</li>
                            </ul>
                            
                            <div class="code-block"><pre><code><span class="comment">// N√≥ da lista encadeada com ponteiro inteligente</span>
<span class="keyword">struct</span> No {
    <span class="type">int</span> valor;                      <span class="comment">// Valor armazenado</span>
    <span class="type">std::unique_ptr&lt;No&gt;</span> proximo;    <span class="comment">// Pr√≥ximo n√≥ (gerenciamento autom√°tico)</span>
    
    <span class="keyword">explicit</span> No(<span class="type">int</span> val) : valor(val), proximo(<span class="keyword">nullptr</span>) {}
};

<span class="keyword">class</span> TabelaEncadeada {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;std::unique_ptr&lt;No&gt;&gt;</span> tabela;  <span class="comment">// Array de listas</span>
    <span class="type">size_t</span> tamanho;                           <span class="comment">// Tamanho da tabela</span>
    <span class="type">size_t</span> numElementos;                      <span class="comment">// Contador de elementos</span>
    
    <span class="comment">// Constante da propor√ß√£o √°urea para multiplica√ß√£o</span>
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> CONSTANTE_MULTIPLICACAO = <span class="number">0.6180339887</span>;

<span class="keyword">public</span>:
    <span class="comment">// Fun√ß√µes de hash dispon√≠veis</span>
    <span class="keyword">enum</span> <span class="keyword">class</span> TipoHash { DIVISAO, MULTIPLICACAO };
    
    <span class="comment">// Interface principal</span>
    <span class="type">void</span> inserir(<span class="type">int</span> valor, TipoHash tipo);
    <span class="type">bool</span> buscar(<span class="type">int</span> valor, TipoHash tipo) <span class="keyword">const</span>;
    
    <span class="comment">// M√©trica importantes</span>
    <span class="type">double</span> fatorCarga() <span class="keyword">const</span>;
    <span class="type">size_t</span> getNumElementos() <span class="keyword">const</span>;
};</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üéØ Vantagens do Encadeamento</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>Sem limite te√≥rico</strong> de elementos</li>
                                <li><strong>Performance degrada graciosamente</strong> com aumento do fator de carga</li>
                                <li><strong>Implementa√ß√£o robusta</strong> e conceitualmente simples</li>
                                <li><strong>Permite remo√ß√£o eficiente</strong> sem problemas de reorganiza√ß√£o</li>
                            </ul>
                        </div>
                    </details>
                </article>

                <!-- TabelaAberta.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaAberta.hpp</code> - Interface da Tabela Hash com Endere√ßamento Aberto</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìã Vis√£o Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Define a implementa√ß√£o de tabela hash com endere√ßamento aberto usando sondagem linear. Todos os elementos s√£o armazenados diretamente no array da tabela, sem estruturas auxiliares. Implementa lazy deletion e controle autom√°tico de fator de carga para manter performance.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üèóÔ∏è Estrutura Celula</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <p class="text-gray-700 text-sm mb-2">Cada c√©lula pode estar em tr√™s estados:</p>
                                <ul class="list-disc list-inside space-y-1 text-gray-700 text-sm">
                                    <li><strong>VAZIO:</strong> Nunca foi ocupada - para busca e permite inser√ß√£o</li>
                                    <li><strong>OCUPADO:</strong> Cont√©m um valor v√°lido</li>
                                    <li><strong>REMOVIDO:</strong> Foi ocupada mas valor foi removido (lazy deletion)</li>
                                </ul>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">‚öôÔ∏è Sondagem Linear</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                O m√©todo <code>sondagemLinear()</code> √© o cora√ß√£o do endere√ßamento aberto. Incrementa sequencialmente o √≠ndice at√© encontrar posi√ß√£o adequada. Comporta-se diferentemente para inser√ß√£o (procura VAZIO/REMOVIDO) e busca (para em VAZIO, continua em REMOVIDO).
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üéõÔ∏è Controle de Fator de Carga</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>MAX_FATOR_CARGA = 0.7:</strong> Limite para manter performance aceit√°vel</li>
                                <li><strong>fatorCarga():</strong> Considera apenas elementos ativos (n√£o removidos)</li>
                                <li><strong>fatorOcupacao():</strong> Inclui elementos removidos para decis√£o de rehash</li>
                                <li><strong>precisaRehash():</strong> Verifica se √© necess√°rio expandir a tabela</li>
                            </ul>
                            
                            <div class="code-block"><pre><code><span class="comment">// Estados poss√≠veis de uma c√©lula</span>
<span class="keyword">struct</span> Celula {
    <span class="keyword">enum</span> <span class="keyword">class</span> Estado { VAZIO, OCUPADO, REMOVIDO };
    
    <span class="type">int</span> valor;
    Estado estado;
    
    <span class="comment">// Construtor para c√©lula vazia</span>
    Celula() : valor(<span class="number">0</span>), estado(Estado::VAZIO) {}
    
    <span class="comment">// Verifica se c√©lula est√° dispon√≠vel para inser√ß√£o</span>
    <span class="type">bool</span> disponivelParaInsercao() <span class="keyword">const</span> {
        <span class="keyword">return</span> estado == Estado::VAZIO || estado == Estado::REMOVIDO;
    }
};

<span class="keyword">class</span> TabelaAberta {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;Celula&gt;</span> tabela;     <span class="comment">// Array √∫nico de c√©lulas</span>
    <span class="type">size_t</span> numElementos;            <span class="comment">// Elementos ativos</span>
    <span class="type">size_t</span> numRemovidos;            <span class="comment">// Elementos removidos</span>
    
    <span class="comment">// Constantes para controle</span>
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> MAX_FATOR_CARGA = <span class="number">0.7</span>;
    
    <span class="comment">// Sondagem linear - cora√ß√£o do endere√ßamento aberto</span>
    <span class="type">size_t</span> sondagemLinear(<span class="type">size_t</span> indiceInicial, <span class="type">int</span> valor, <span class="type">bool</span> paraInsercao) <span class="keyword">const</span>;

<span class="keyword">public</span>:
    <span class="comment">// Lazy deletion - marca como removido sem reorganizar</span>
    <span class="type">std::optional&lt;int&gt;</span> remover(<span class="type">int</span> valor, TipoHash tipo);
    
    <span class="comment">// Controle de fator de carga</span>
    <span class="type">double</span> fatorCarga() <span class="keyword">const</span>;      <span class="comment">// Apenas elementos ativos</span>
    <span class="type">double</span> fatorOcupacao() <span class="keyword">const</span>;    <span class="comment">// Inclui removidos</span>
    <span class="type">bool</span> precisaRehash() <span class="keyword">const</span>;
};</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üéØ Vantagens do Endere√ßamento Aberto</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Maior efici√™ncia de mem√≥ria</strong> - sem ponteiros extras</li>
                                <li><strong>Melhor localidade de cache</strong> - dados cont√≠guos</li>
                                <li><strong>Performance excelente</strong> com baixo fator de carga</li>
                                <li><strong>Menos aloca√ß√µes din√¢micas</strong></li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">‚ö†Ô∏è Desafios</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>Clustering prim√°rio</strong> - elementos tendem a se agrupar</li>
                                <li><strong>Performance degrada rapidamente</strong> com alto fator de carga</li>
                                <li><strong>Lazy deletion necess√°ria</strong> para manter integridade da sondagem</li>
                            </ul>
                        </div>
                    </details>
                </article>

                <!-- CarregadorDados.hpp -->
                <article>
                    <details>
                        <summary><code>include/CarregadorDados.hpp</code> - Interface do Gerenciador de Datasets</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìã Vis√£o Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Classe especializada no gerenciamento de datasets para os testes de tabelas hash. Sua fun√ß√£o principal √© <strong>carregar</strong> dados de arquivos na pasta <code>data/</code>, mas tamb√©m oferece funcionalidades complementares como gera√ß√£o de dados aleat√≥rios, valida√ß√£o de arquivos e an√°lise estat√≠stica.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üé≤ Sistema de Gera√ß√£o Aleat√≥ria</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <p class="text-gray-700 text-sm mb-2">Utiliza std::mt19937 (Mersenne Twister) para gera√ß√£o de alta qualidade:</p>
                                <ul class="list-disc list-inside space-y-1 text-gray-700 text-sm">
                                    <li><strong>Seed configur√°vel:</strong> Permite reprodutibilidade ou aleatoriedade</li>
                                    <li><strong>Distribui√ß√£o uniforme:</strong> std::uniform_int_distribution garante distribui√ß√£o uniforme</li>
                                    <li><strong>Faixa ajust√°vel:</strong> Valores entre 1 e 1.000.000 por padr√£o</li>
                                </ul>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìÅ Carregamento Robusto de Arquivos</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Formato flex√≠vel:</strong> Suporta arquivos com ou sem header de quantidade</li>
                                <li><strong>Tratamento de erros:</strong> Continua processamento mesmo com linhas inv√°lidas</li>
                                <li><strong>Limpeza autom√°tica:</strong> Remove espa√ßos em branco e linhas vazias</li>
                                <li><strong>Valida√ß√£o de integridade:</strong> Verifica consist√™ncia dos dados carregados</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìä An√°lise Estat√≠stica</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                A estrutura <code>InfoDataset</code> encapsula informa√ß√µes completas sobre um dataset: quantidade de elementos, valores m√≠nimo/m√°ximo, m√©dia aritm√©tica, an√°lise de duplicatas. Essencial para caracterizar a qualidade dos dados de teste.
                            </p>
                            
                            <div class="code-block"><pre><code><span class="keyword">class</span> CarregadorDados {
<span class="keyword">private</span>:
    <span class="type">std::mt19937</span> gerador;                           <span class="comment">// Mersenne Twister</span>
    <span class="type">std::uniform_int_distribution&lt;int&gt;</span> distribuicao; <span class="comment">// Distribui√ß√£o uniforme</span>
    
    <span class="comment">// Utilit√°rios internos</span>
    <span class="type">bool</span> arquivoExiste(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
    <span class="type">std::string</span> trim(<span class="keyword">const</span> <span class="type">std::string</span>&amp; str) <span class="keyword">const</span>;

<span class="keyword">public</span>:
    <span class="comment">// Carregamento principal - fun√ß√£o core</span>
    <span class="type">std::vector&lt;int&gt;</span> carregarDeArquivo(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
    
    <span class="comment">// Gera√ß√£o de dados para testes</span>
    <span class="type">std::vector&lt;int&gt;</span> gerarNumerosAleatorios(<span class="type">size_t</span> quantidade);           <span class="comment">// √önicos</span>
    <span class="type">std::vector&lt;int&gt;</span> gerarNumerosAleatoriosComRepeticao(<span class="type">size_t</span> quantidade); <span class="comment">// Permite duplicatas</span>
    
    <span class="comment">// Estrutura para an√°lise de datasets</span>
    <span class="keyword">struct</span> InfoDataset {
        <span class="type">std::string</span> nomeArquivo;    <span class="comment">// Nome do arquivo</span>
        <span class="type">size_t</span> quantidade;          <span class="comment">// N√∫mero de elementos</span>
        <span class="type">int</span> minimo, maximo;         <span class="comment">// Faixa de valores</span>
        <span class="type">double</span> media;               <span class="comment">// M√©dia aritm√©tica</span>
        <span class="type">bool</span> temDuplicatas;         <span class="comment">// Se cont√©m duplicatas</span>
        <span class="type">size_t</span> numDuplicatas;       <span class="comment">// Quantidade de duplicatas</span>
    };
    
    <span class="comment">// An√°lise e valida√ß√£o</span>
    InfoDataset analisarDataset(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
    <span class="type">bool</span> validarArquivo(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
    <span class="type">void</span> exibirEstatisticas(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
};</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üîß Funcionalidades Auxiliares</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>gerarArquivosTrabalho():</strong> Cria automaticamente todos os datasets necess√°rios (100 a 50.000)</li>
                                <li><strong>listarArquivosDisponiveis():</strong> Escaneia pasta data/ e lista arquivos .txt encontrados</li>
                                <li><strong>salvarEmArquivo():</strong> Persiste dados no formato padronizado do projeto</li>
                                <li><strong>BenchmarkCarregadorDados:</strong> Classe utilit√°ria para testar performance das opera√ß√µes</li>
                            </ul>
                        </div>
                    </details>
                </article>
                
                <!-- Implementa√ß√µes .cpp -->
                <article>
                    <details>
                        <summary><code>src/*.cpp</code> - Arquivos de Implementa√ß√£o</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìã Vis√£o Geral das Implementa√ß√µes</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Todos os arquivos .cpp cont√™m implementa√ß√µes completas e otimizadas dos m√©todos definidos nos headers correspondentes. Cada implementa√ß√£o inclui documenta√ß√£o detalhada, tratamento de erros, e otimiza√ß√µes espec√≠ficas para m√°xima performance nos benchmarks.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üîç TabelaEncadeada.cpp - Caracter√≠sticas T√©cnicas</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Inser√ß√£o otimizada:</strong> Inser√ß√£o no in√≠cio das listas para O(1), com verifica√ß√£o de duplicatas</li>
                                <li><strong>Busca eficiente:</strong> Percorre lista sequencialmente at√© encontrar elemento ou nullptr</li>
                                <li><strong>Remo√ß√£o robusta:</strong> Trata casos especiais (primeiro elemento vs. meio da lista)</li>
                                <li><strong>Estat√≠sticas avan√ßadas:</strong> Calcula distribui√ß√£o, clustering, e colis√µes reais</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">‚ö° TabelaAberta.cpp - Aspectos de Performance</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Sondagem linear otimizada:</strong> Algoritmo central que determina posi√ß√µes para inser√ß√£o/busca</li>
                                <li><strong>Lazy deletion inteligente:</strong> Mant√©m integridade da sondagem sem reorganiza√ß√£o custosa</li>
                                <li><strong>An√°lise de clustering:</strong> Detecta e mede agrupamentos prim√°rios automaticamente</li>
                                <li><strong>Controle preventivo:</strong> Monitora fator de carga para evitar degrada√ß√£o severa</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üìà CarregadorDados.cpp - Robustez e Flexibilidade</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Parsing inteligente:</strong> Detecta automaticamente formato do arquivo (com/sem header)</li>
                                <li><strong>Recupera√ß√£o de erros:</strong> Continua processamento mesmo com linhas corrompidas</li>
                                <li><strong>Gera√ß√£o eficiente:</strong> Algoritmos otimizados para datasets grandes</li>
                                <li><strong>An√°lise estat√≠stica completa:</strong> Calcula m√©tricas descritivas usando algoritmos numericamente est√°veis</li>
                            </ul>
                            
                            <div class="code-block"><pre><code><span class="comment">// Exemplo: Inser√ß√£o otimizada na tabela encadeada</span>
<span class="type">void</span> TabelaEncadeada::inserir(<span class="type">int</span> valor, TipoHash tipo) {
    <span class="comment">// 1. Calcula √≠ndice usando fun√ß√£o hash especificada</span>
    <span class="type">size_t</span> indice = (tipo == TipoHash::DIVISAO) 
        ? calcularHashDivisao(valor) 
        : calcularHashMultiplicacao(valor);
    
    <span class="comment">// 2. Verifica duplicatas (importante para integridade)</span>
    <span class="keyword">if</span> (buscar(valor, tipo)) {
        <span class="keyword">return</span>; <span class="comment">// Elemento j√° existe</span>
    }
    
    <span class="comment">// 3. Inser√ß√£o no in√≠cio (O(1)) usando ponteiros inteligentes</span>
    <span class="keyword">auto</span> novoNo = <span class="type">std::make_unique&lt;No&gt;</span>(valor);
    novoNo-&gt;proximo = <span class="type">std::move</span>(tabela[indice]);
    tabela[indice] = <span class="type">std::move</span>(novoNo);
    
    ++numElementos;
}

<span class="comment">// Exemplo: Sondagem linear na tabela aberta</span>
<span class="type">size_t</span> TabelaAberta::sondagemLinear(<span class="type">size_t</span> indiceInicial, <span class="type">int</span> valor, <span class="type">bool</span> paraInsercao) <span class="keyword">const</span> {
    <span class="type">size_t</span> tentativas = <span class="number">0</span>;
    <span class="type">size_t</span> indice = indiceInicial;
    
    <span class="keyword">while</span> (tentativas &lt; tamanho) {
        <span class="keyword">const</span> Celula&amp; celula = tabela[indice];
        
        <span class="keyword">if</span> (paraInsercao) {
            <span class="comment">// Para inser√ß√£o: aceita VAZIO ou REMOVIDO</span>
            <span class="keyword">if</span> (celula.disponivelParaInsercao()) <span class="keyword">return</span> indice;
        } <span class="keyword">else</span> {
            <span class="comment">// Para busca: para em VAZIO, continua em REMOVIDO</span>
            <span class="keyword">if</span> (celula.estado == Celula::Estado::VAZIO) <span class="keyword">return</span> tamanho;
            <span class="keyword">if</span> (celula.estado == Celula::Estado::OCUPADO &amp;&amp; celula.valor == valor) {
                <span class="keyword">return</span> indice;
            }
        }
        
        <span class="comment">// Avan√ßa circularmente</span>
        indice = (indice + <span class="number">1</span>) % tamanho;
        ++tentativas;
    }
    
    <span class="keyword">return</span> tamanho; <span class="comment">// N√£o encontrou</span>
}</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">üèÜ Padr√µes de Qualidade Implementados</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>Documenta√ß√£o Doxygen completa</strong> com descri√ß√µes detalhadas de complexidade</li>
                                <li><strong>Tratamento robusto de exce√ß√µes</strong> com mensagens informativas</li>
                                <li><strong>Uso consistente de C++17</strong> com smart pointers e containers STL</li>
                                <li><strong>Otimiza√ß√µes de performance</strong> espec√≠ficas para benchmarking</li>
                                <li><strong>C√≥digo defensivo</strong> com valida√ß√µes de entrada e estados</li>
                            </ul>
                        </div>
                    </details>
                </article>
            </div>
        </section>

        <!-- Resultados e Gr√°ficos -->
        <section id="graficos" class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">4. Resultados e Gr√°ficos</h2>
            <p class="mb-6 text-gray-700">
                Os gr√°ficos abaixo apresentam uma an√°lise visual do desempenho das diferentes implementa√ß√µes de tabela hash. Use os filtros para comparar os cen√°rios e clique no bot√£o para baixar uma imagem do gr√°fico.
            </p>

            <!-- Controles do Gr√°fico -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 p-4 bg-gray-50 rounded-lg border">
                <div>
                    <label for="chartType" class="block text-sm font-medium text-gray-700">M√©trica de An√°lise:</label>
                    <select id="chartType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="insertion" selected>Tempo de Inser√ß√£o (ms)</option>
                        <option value="search">Tempo de Busca (ms)</option>
                        <option value="collisions">Colis√µes</option>
                    </select>
                </div>
                <div>
                    <label for="tableType" class="block text-sm font-medium text-gray-700">Tipo de Tabela Hash:</label>
                    <select id="tableType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Encadeada">Encadeada</option>
                        <option value="Aberta">Aberta</option>
                    </select>
                </div>
                 <div>
                    <label for="hashFunction" class="block text-sm font-medium text-gray-700">Fun√ß√£o de Hash:</label>
                    <select id="hashFunction" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Divisao">Divis√£o</option>
                        <option value="Multiplicacao">Multiplica√ß√£o</option>
                    </select>
                </div>
            </div>

            <!-- Container do Gr√°fico -->
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
            <div class="text-center mt-4">
                <button id="downloadChartBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-300">
                    Baixar Gr√°fico
                </button>
            </div>
        </section>

         <!-- Conclus√£o -->
        <section id="conclusao" class="mt-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">5. Conclus√£o</h2>
            <p class="text-gray-700 leading-relaxed">
                A an√°lise comparativa revelou insights importantes sobre o comportamento das diferentes estrat√©gias de hashing. A <strong>TabelaEncadeada</strong> demonstrou ser mais robusta e previs√≠vel, especialmente em cen√°rios com alto fator de carga, onde o desempenho de inser√ß√£o e busca degrada de forma mais suave. Embora possa consumir mais mem√≥ria devido √†s listas, sua performance √© menos sens√≠vel √† qualidade da fun√ß√£o de hash.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                Por outro lado, a <strong>TabelaAberta</strong> se mostrou extremamente eficiente em cen√°rios de baixo fator de carga, superando a vers√£o encadeada devido √† melhor localidade de cache e menor sobrecarga de aloca√ß√£o de mem√≥ria. No entanto, seu desempenho decai drasticamente √† medida que a tabela se aproxima de sua capacidade m√°xima, tornando-a inadequada para cen√°rios onde o n√∫mero de elementos √© pr√≥ximo ao tamanho da tabela.
            </p>
             <p class="text-gray-700 leading-relaxed mt-4">
                Entre as fun√ß√µes de hash, n√£o houve um vencedor claro em todos os cen√°rios, mas a fun√ß√£o de <strong>divis√£o</strong> apresentou, em m√©dia, uma distribui√ß√£o ligeiramente melhor e menos colis√µes, principalmente para a tabela de endere√ßamento aberto. A escolha da abordagem ideal depende, portanto, dos requisitos espec√≠ficos da aplica√ß√£o, como a previsibilidade do n√∫mero de elementos, as restri√ß√µes de mem√≥ria e a performance desejada.
            </p>
        </section>

    </main>

    <footer class="bg-white mt-12">
        <div class="container mx-auto px-6 py-4 text-center text-gray-500">
            <p>Desenvolvido para a disciplina de Pesquisa e Ordena√ß√£o.</p>
        </div>
    </footer>

    <script>
        // Data from resultados_benchmark.csv
        const csvData = `TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga
Encadeada,29,100,Divisao,0.010,0.018,71,3.4483
Encadeada,29,100,Multiplicacao,0.009,0.028,71,3.4483
Encadeada,97,100,Divisao,0.008,0.014,37,1.0309
Encadeada,97,100,Multiplicacao,0.008,0.023,37,1.0309
Encadeada,251,100,Divisao,0.006,0.014,0,0.3984
Encadeada,251,100,Multiplicacao,0.005,0.013,0,0.3984
Encadeada,499,100,Divisao,0.009,0.007,0,0.2004
Encadeada,499,100,Multiplicacao,0.006,0.012,0,0.2004
Encadeada,911,100,Divisao,0.007,0.005,0,0.1098
Encadeada,911,100,Multiplicacao,0.007,0.006,0,0.1098
Aberta,101,100,Divisao,0.007,0.004,50,0.9901
Aberta,101,100,Multiplicacao,0.007,0.004,50,0.9901
Aberta,251,100,Divisao,0.005,0.003,0,0.3984
Aberta,251,100,Multiplicacao,0.006,0.003,0,0.3984
Aberta,499,100,Divisao,0.006,0.002,0,0.2004
Aberta,499,100,Multiplicacao,0.006,0.003,0,0.2004
Aberta,911,100,Divisao,0.006,0.003,0,0.1098
Aberta,911,100,Multiplicacao,0.006,0.003,0,0.1098
Encadeada,29,500,Divisao,0.100,0.279,471,17.2414
Encadeada,29,500,Multiplicacao,0.086,0.258,471,17.2414
Encadeada,97,500,Divisao,0.049,0.119,403,5.1546
Encadeada,97,500,Multiplicacao,0.053,0.103,403,5.1546
Encadeada,251,500,Divisao,0.035,0.057,249,1.9920
Encadeada,251,500,Multiplicacao,0.037,0.051,249,1.9920
Encadeada,499,500,Divisao,0.030,0.024,1,0.0020
Encadeada,499,500,Multiplicacao,0.031,0.027,1,0.0020
Encadeada,911,500,Divisao,0.028,0.015,0,0.5488
Encadeada,911,500,Multiplicacao,0.028,0.019,0,0.5488
Aberta,503,500,Divisao,0.031,0.015,249,0.9940
Aberta,503,500,Multiplicacao,0.032,0.015,249,0.9940
Aberta,911,500,Divisao,0.028,0.012,0,0.5488
Aberta,911,500,Multiplicacao,0.029,0.014,0,0.5488
Encadeada,29,1000,Divisao,0.284,0.767,971,34.4828
Encadeada,29,1000,Multiplicacao,0.297,0.911,971,34.4828
Encadeada,97,1000,Divisao,0.119,0.287,903,10.3093
Encadeada,97,1000,Multiplicacao,0.115,0.263,903,10.3093
Encadeada,251,1000,Divisao,0.076,0.123,749,3.9841
Encadeada,251,1000,Multiplicacao,0.076,0.111,749,3.9841
Encadeada,499,1000,Divisao,0.063,0.059,501,2.0040
Encadeada,499,1000,Multiplicacao,0.066,0.060,501,2.0040
Encadeada,911,1000,Divisao,0.058,0.032,89,1.0977
Encadeada,911,1000,Multiplicacao,0.057,0.035,89,1.0977
Aberta,1009,1000,Divisao,0.057,0.028,496,0.9911
Aberta,1009,1000,Multiplicacao,0.062,0.030,496,0.9911
Encadeada,29,5000,Divisao,4.329,8.514,4971,172.4138
Encadeada,29,5000,Multiplicacao,4.551,9.088,4971,172.4138
Encadeada,97,5000,Divisao,1.442,3.159,4903,51.5464
Encadeada,97,5000,Multiplicacao,1.558,3.226,4903,51.5464
Encadeada,251,5000,Divisao,0.592,1.011,4750,19.9203
Encadeada,251,5000,Multiplicacao,0.594,0.932,4750,19.9203
Encadeada,499,5000,Divisao,0.379,0.510,4501,10.0200
Encadeada,499,5000,Multiplicacao,0.395,0.479,4501,10.0200
Encadeada,911,5000,Divisao,0.292,0.252,4089,5.4885
Encadeada,911,5000,Multiplicacao,0.291,0.254,4089,5.4885
Aberta,5003,5000,Divisao,0.290,0.141,2493,0.9994
Aberta,5003,5000,Multiplicacao,0.312,0.155,2493,0.9994
Encadeada,29,10000,Divisao,10.647,1.779,9922,343.1379
Encadeada,29,10000,Multiplicacao,9.404,1.932,9922,343.1379
Encadeada,97,10000,Divisao,3.794,1.424,9854,102.5876
Encadeada,97,10000,Multiplicacao,3.483,0.541,9854,102.5876
Encadeada,251,10000,Divisao,1.358,0.195,9700,39.6454
Encadeada,251,10000,Multiplicacao,1.445,0.205,9700,39.6454
Encadeada,499,10000,Divisao,0.896,0.103,9500,20.0401
Encadeada,499,10000,Multiplicacao,0.875,0.102,9500,20.0401
Encadeada,911,10000,Divisao,0.618,0.061,9088,10.9769
Encadeada,911,10000,Multiplicacao,0.609,0.060,9088,10.9769
Aberta,10007,10000,Divisao,0.612,0.303,4992,0.9993
Aberta,10007,10000,Multiplicacao,0.627,0.320,4992,0.9993
Encadeada,29,50000,Divisao,315.341,833.111,49971,1724.1379
Encadeada,29,50000,Multiplicacao,305.981,852.179,49971,1724.1379
Encadeada,97,50000,Divisao,93.992,260.912,49903,515.4639
Encadeada,97,50000,Multiplicacao,97.388,272.871,49903,515.4639
Encadeada,251,50000,Divisao,36.561,91.879,49750,199.2032
Encadeada,251,50000,Multiplicacao,37.330,96.678,49750,199.2032
Encadeada,499,50000,Divisao,21.841,50.111,49501,100.2004
Encadeada,499,50000,Multiplicacao,22.251,52.288,49501,100.2004
Encadeada,911,50000,Divisao,13.790,29.332,49089,54.8847
Encadeada,911,50000,Multiplicacao,13.679,28.690,49089,54.8847
Aberta,50021,50000,Divisao,15.223,7.568,24982,0.9996
Aberta,50021,50000,Multiplicacao,15.178,7.741,24982,0.9996`;

        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const entry = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    entry[header] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                });
                return entry;
            });
        }

        const benchmarkData = parseCSV(csvData);
        let myChart;

        const chartConfig = {
            insertion: {
                label: 'Tempo de Inser√ß√£o (ms)',
                key: 'TempoInsercao(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            search: {
                label: 'Tempo de Busca (ms)',
                key: 'TempoBusca(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            collisions: {
                label: 'Colis√µes',
                key: 'Colisoes',
                yAxisLabel: 'N√∫mero de Colis√µes'
            }
        };

        const colors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };
         const borderColors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };


        function updateChart() {
            const chartType = document.getElementById('chartType').value;
            const tableType = document.getElementById('tableType').value;
            const hashFunction = document.getElementById('hashFunction').value;

            const selectedConfig = chartConfig[chartType];

            let filteredData = benchmarkData;
            if (tableType !== 'all') {
                filteredData = filteredData.filter(d => d.TipoTabela === tableType);
            }
            if (hashFunction !== 'all') {
                filteredData = filteredData.filter(d => d.FuncaoHash === hashFunction);
            }
            
            const labels = [...new Set(filteredData.map(d => d.QuantidadeDados))].sort((a,b) => a - b);

            const datasets = [];
            const combinations = [...new Set(filteredData.map(d => `${d.TipoTabela}-${d.FuncaoHash}`))];;

            combinations.forEach(combo => {
                const [tipo, hash] = combo.split('-');
                
                const dataForCombo = filteredData.filter(d => d.TipoTabela === tipo && d.FuncaoHash === hash);
                
                // Agrupar por QuantidadeDados e pegar a m√©dia para evitar multiplos pontos
                const dataPoints = labels.map(label => {
                    const points = dataForCombo
                        .filter(d => d.QuantidadeDados === label)
                        .map(d => d[selectedConfig.key]);
                    return points.length > 0 ? points.reduce((a, b) => a + b, 0) / points.length : null;
                });
                
                datasets.push({
                    label: `${tipo} - ${hash}`,
                    data: dataPoints,
                    borderColor: borderColors[combo],
                    backgroundColor: colors[combo].replace('1)', '0.2)'),
                    fill: false,
                    tension: 0.1
                });
            });


            const ctx = document.getElementById('benchmarkChart').getContext('2d');
            if (myChart) {
                myChart.destroy();
            }
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectedConfig.label} vs. Quantidade de Dados`,
                            font: { size: 18 }
                        },
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Quantidade de Dados Inseridos'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: selectedConfig.yAxisLabel
                            },
                             type: 'logarithmic',
                             ticks: {
                                callback: function(value, index, values) {
                                    if (value >= 1000) {
                                        return value.toExponential();
                                    }
                                    return Number(value.toString());
                                }
                            }
                        }
                    }
                }
            });
        }

        document.getElementById('chartType').addEventListener('change', updateChart);
        document.getElementById('tableType').addEventListener('change', updateChart);
        document.getElementById('hashFunction').addEventListener('change', updateChart);
        
        document.getElementById('downloadChartBtn').addEventListener('click', () => {
            const chartCanvas = document.getElementById('benchmarkChart');
            const url = chartCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = url;
            link.download = `grafico_benchmark_${new Date().getTime()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initial chart render
        window.addEventListener('load', updateChart);

    </script>
</body>
</html>