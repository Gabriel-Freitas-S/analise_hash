<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabalho 2: Análise de Tabela Hash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
        }
        .code-block .keyword { color: #93c5fd; } /* blue-300 */
        .code-block .type { color: #6ee7b7; } /* emerald-300 */
        .code-block .comment { color: #6b7280; } /* gray-500 */
        .code-block .string { color: #fde047; } /* yellow-300 */
        .code-block .number { color: #f9a8d4; } /* pink-300 */
        .code-block .preprocessor { color: #d8b4fe; } /* purple-300 */
        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
        }
        details > summary {
            cursor: pointer;
            font-weight: 600;
            padding: 0.75rem 1rem;
            background-color: #f3f4f6; /* gray-100 */
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        details > summary:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        details[open] > summary {
            background-color: #e5e7eb; /* gray-200 */
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details > summary::after {
            content: '▼';
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        details[open] > summary::after {
            transform: rotate(180deg);
        }
        .details-content {
            padding: 1.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header -->
    <header class="bg-white shadow-md">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-3xl font-bold text-gray-900">Análise Comparativa de Soluções Baseadas em Hashing</h1>
            <p class="text-lg text-gray-600 mt-1">Disciplina: Pesquisa e Ordenação</p>
        </div>
    </header>

    <main class="container mx-auto px-6 py-8">
        
        <!-- Seção de Introdução -->
        <section id="introducao" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">1. Introdução</h2>
            <p class="text-gray-700 leading-relaxed">
                O hashing é uma técnica fundamental em ciência da computação, usada para armazenar e recuperar dados de forma eficiente. A eficácia de um sistema de hashing depende crucialmente da função de hash e da estratégia de tratamento de colisões. Este trabalho implementa e analisa comparativamente duas soluções de hashing: <strong>Tabela Hash com Endereçamento Aberto</strong> e <strong>Tabela Hash com Encadeamento Separado</strong>.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                A análise explora duas funções de hashing distintas — uma baseada em divisão e outra em multiplicação — para avaliar o desempenho de cada abordagem em diferentes cenários de carga de dados e tamanho da tabela. O objetivo é identificar as vantagens, desvantagens e os comportamentos específicos de cada combinação, fornecendo uma visão clara sobre sua aplicabilidade prática.
            </p>
        </section>

        <!-- Estrutura do Projeto -->
        <section id="estrutura" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">2. Estrutura do Projeto</h2>
            <p class="mb-4 text-gray-700">O projeto foi organizado de forma modular para separar as definições das classes, suas implementações e os dados de teste. A estrutura atual reflete nomes mais claros e apropriados para cada componente.</p>
            <div class="code-block">
                <pre>
/
├── CMakeLists.txt              <span class="comment">// Arquivo de configuração do build com CMake</span>
├── data/                        <span class="comment">// Diretório para os conjuntos de dados de entrada</span>
│   ├── numeros_aleatorios_100.txt
│   ├── numeros_aleatorios_500.txt
│   ├── numeros_aleatorios_1000.txt
│   ├── numeros_aleatorios_5000.txt
│   ├── numeros_aleatorios_10000.txt
│   └── numeros_aleatorios_50000.txt
├── include/                     <span class="comment">// Arquivos de cabeçalho (.hpp) com as definições das classes</span>
│   ├── CarregadorDados.hpp       <span class="comment">// Carregamento de datasets da pasta data/</span>
│   ├── TabelaEncadeada.hpp       <span class="comment">// Tabela hash com encadeamento</span>
│   └── TabelaAberta.hpp          <span class="comment">// Tabela hash com endereçamento aberto</span>
├── src/                         <span class="comment">// Arquivos de código-fonte (.cpp) com as implementações</span>
│   ├── main.cpp                  <span class="comment">// Ponto de entrada, orquestra os benchmarks</span>
│   ├── CarregadorDados.cpp       <span class="comment">// Implementação do carregador</span>
│   ├── TabelaEncadeada.cpp       <span class="comment">// Implementação do encadeamento</span>
│   └── TabelaAberta.cpp          <span class="comment">// Implementação do endereçamento aberto</span>
├── index.html                   <span class="comment">// Página web com análise completa</span>
└── resultados_benchmark.csv     <span class="comment">// Arquivo de saída com os resultados dos testes</span>
                </pre>
            </div>
        </section>

        <!-- Análise do Código-Fonte -->
        <section id="codigo" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">3. Análise Detalhada do Código-Fonte</h2>
            <p class="text-gray-700 leading-relaxed mb-6">
                Esta seção apresenta uma análise técnica detalhada de cada componente do projeto, explicando as decisões de design, algoritmos implementados e complexidades computacionais. Todos os arquivos foram desenvolvidos seguindo boas práticas de programação C++17 e incluem documentação profissional completa.
            </p>
            
            <div class="space-y-4">
                <!-- main.cpp -->
                <article>
                    <details>
                        <summary><code>src/main.cpp</code> - Programa Principal e Orquestrador de Benchmarks</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📋 Visão Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                O arquivo <code>main.cpp</code> é o coração do sistema de benchmarking, responsável por coordenar todos os testes comparativos entre as diferentes implementações de tabelas hash. Implementa um framework robusto de medição de performance que executa testes sistemáticos e gera relatórios detalhados.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🏗️ Arquitetura Principal</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>ResultadoTeste:</strong> Estrutura que encapsula todas as métricas de um teste específico (tempos, colisões, fator de carga)</li>
                                <li><strong>BenchmarkManager:</strong> Classe gerenciadora que coordena execução de testes, coleta de dados e geração de relatórios</li>
                                <li><strong>Template medirTempo():</strong> Função genérica para medição precisa usando std::chrono::high_resolution_clock</li>
                                <li><strong>Algoritmos de estimativa:</strong> Funções matemáticas para calcular colisões esperadas baseadas em teoria probabilística</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">⚙️ Funcionalidades Técnicas</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <h5 class="font-semibold mb-2">Medição de Performance</h5>
                                <p class="text-gray-700 text-sm mb-2">Utiliza std::chrono para medições em microssegundos, convertidas para milissegundos para legibilidade. O template permite medição de qualquer função lambda.</p>
                                
                                <h5 class="font-semibold mb-2">Estimativa de Colisões</h5>
                                <p class="text-gray-700 text-sm mb-2"><strong>Encadeamento:</strong> Baseada na distribuição de Poisson: colisões ≈ n - m(1 - e^(-λ)), onde λ = n/m</p>
                                <p class="text-gray-700 text-sm"><strong>Endereçamento Aberto:</strong> Considera clustering primário: colisões ≈ n × fc / 2</p>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🔄 Fluxo de Execução</h4>
                            <ol class="list-decimal list-inside space-y-2 text-gray-700 mb-4">
                                <li>Inicialização de componentes (CarregadorDados, BenchmarkManager)</li>
                                <li>Geração de dataset para operações de busca (1000 números aleatórios)</li>
                                <li>Loop principal através dos arquivos de dataset (100 a 50.000 elementos)</li>
                                <li>Para cada dataset: testa todas as configurações de tabela encadeada e aberta</li>
                                <li>Medição precisa de tempos de inserção e busca</li>
                                <li>Cálculo de estatísticas (colisões, fator de carga)</li>
                                <li>Geração de relatórios (console + CSV)</li>
                            </ol>
                            
                            <div class="code-block"><pre><code><span class="comment">// Estrutura para encapsular resultados de teste</span>
<span class="keyword">struct</span> ResultadoTeste {
    <span class="type">std::string</span> tipoTabela;      <span class="comment">// "Encadeada" ou "Aberta"</span>
    <span class="type">size_t</span> tamanhoTabela;        <span class="comment">// Tamanho da tabela hash</span>
    <span class="type">size_t</span> quantidadeDados;      <span class="comment">// Elementos inseridos</span>
    <span class="type">std::string</span> tipoFuncaoHash;  <span class="comment">// "Divisao" ou "Multiplicacao"</span>
    <span class="type">double</span> tempoInsercao;        <span class="comment">// Tempo em milissegundos</span>
    <span class="type">double</span> tempoBusca;           <span class="comment">// Tempo em milissegundos</span>
    <span class="type">size_t</span> colisoes;             <span class="comment">// Estimativa de colisões</span>
    <span class="type">double</span> fatorCarga;           <span class="comment">// elementos/tamanho</span>
};

<span class="comment">// Template para medição precisa de tempo</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;
<span class="type">double</span> medirTempo(Func&amp;&amp; func) {
    <span class="keyword">auto</span> inicio = <span class="type">std::chrono::high_resolution_clock::now</span>();
    func();  <span class="comment">// Executa função a ser medida</span>
    <span class="keyword">auto</span> fim = <span class="type">std::chrono::high_resolution_clock::now</span>();
    
    <span class="comment">// Converte para milissegundos com precisão decimal</span>
    <span class="keyword">auto</span> duracao = <span class="type">std::chrono::duration_cast&lt;std::chrono::microseconds&gt;</span>(fim - inicio);
    <span class="keyword">return</span> duracao.count() / <span class="number">1000.0</span>;
}</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📊 Complexidade e Performance</h4>
                            <p class="text-gray-700 leading-relaxed">
                                <strong>Complexidade total:</strong> O(k × n × t) onde k = número de datasets, n = tamanho médio dos datasets, t = configurações testadas. O programa é otimizado para minimizar overhead de medição e utiliza tratamento robusto de exceções para continuar execução mesmo com falhas individuais.
                            </p>
                        </div>
                    </details>
                </article>

                <!-- TabelaEncadeada.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaEncadeada.hpp</code> - Interface da Tabela Hash com Encadeamento</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📋 Visão Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Define a interface completa da implementação de tabela hash com encadeamento (separate chaining). Utiliza listas encadeadas com ponteiros inteligentes para garantir segurança de memória e performance otimizada. Cada posição da tabela pode conter uma lista de elementos que colidiram no mesmo índice.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🏗️ Estruturas Principais</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <h5 class="font-semibold mb-2">Estrutura No</h5>
                                <p class="text-gray-700 text-sm mb-2">Representa um nó da lista encadeada com std::unique_ptr para gerenciamento automático de memória. Evita vazamentos e simplifica destruição.</p>
                                
                                <h5 class="font-semibold mb-2">Classe TabelaEncadeada</h5>
                                <p class="text-gray-700 text-sm mb-2">Contém std::vector de unique_ptr para as listas, garantindo que cada posição possa ter uma lista independente de tamanho variável.</p>
                                
                                <h5 class="font-semibold mb-2">Enum TipoHash</h5>
                                <p class="text-gray-700 text-sm">Define os dois métodos de hashing: DIVISAO (k mod m) e MULTIPLICACAO (baseado na proporção áurea).</p>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">⚙️ Métodos Principais</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>inserir():</strong> Insere no início da lista (O(1)) após verificar duplicatas</li>
                                <li><strong>buscar():</strong> Percorre lista sequencialmente (O(1) médio, O(n) pior caso)</li>
                                <li><strong>remover():</strong> Remove elemento e reconecta ponteiros (O(1) médio)</li>
                                <li><strong>calcularHashDivisao():</strong> h(k) = |k| mod m (simples e eficiente)</li>
                                <li><strong>calcularHashMultiplicacao():</strong> h(k) = ⌊m × ((k × A) mod 1)⌋ onde A = 0.618...</li>
                            </ul>
                            
                            <div class="code-block"><pre><code><span class="comment">// Nó da lista encadeada com ponteiro inteligente</span>
<span class="keyword">struct</span> No {
    <span class="type">int</span> valor;                      <span class="comment">// Valor armazenado</span>
    <span class="type">std::unique_ptr&lt;No&gt;</span> proximo;    <span class="comment">// Próximo nó (gerenciamento automático)</span>
    
    <span class="keyword">explicit</span> No(<span class="type">int</span> val) : valor(val), proximo(<span class="keyword">nullptr</span>) {}
};

<span class="keyword">class</span> TabelaEncadeada {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;std::unique_ptr&lt;No&gt;&gt;</span> tabela;  <span class="comment">// Array de listas</span>
    <span class="type">size_t</span> tamanho;                           <span class="comment">// Tamanho da tabela</span>
    <span class="type">size_t</span> numElementos;                      <span class="comment">// Contador de elementos</span>
    
    <span class="comment">// Constante da proporção áurea para multiplicação</span>
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> CONSTANTE_MULTIPLICACAO = <span class="number">0.6180339887</span>;

<span class="keyword">public</span>:
    <span class="comment">// Funções de hash disponíveis</span>
    <span class="keyword">enum</span> <span class="keyword">class</span> TipoHash { DIVISAO, MULTIPLICACAO };
    
    <span class="comment">// Interface principal</span>
    <span class="type">void</span> inserir(<span class="type">int</span> valor, TipoHash tipo);
    <span class="type">bool</span> buscar(<span class="type">int</span> valor, TipoHash tipo) <span class="keyword">const</span>;
    
    <span class="comment">// Métrica importantes</span>
    <span class="type">double</span> fatorCarga() <span class="keyword">const</span>;
    <span class="type">size_t</span> getNumElementos() <span class="keyword">const</span>;
};</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🎯 Vantagens do Encadeamento</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>Sem limite teórico</strong> de elementos</li>
                                <li><strong>Performance degrada graciosamente</strong> com aumento do fator de carga</li>
                                <li><strong>Implementação robusta</strong> e conceitualmente simples</li>
                                <li><strong>Permite remoção eficiente</strong> sem problemas de reorganização</li>
                            </ul>
                        </div>
                    </details>
                </article>

                <!-- TabelaAberta.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaAberta.hpp</code> - Interface da Tabela Hash com Endereçamento Aberto</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📋 Visão Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Define a implementação de tabela hash com endereçamento aberto usando sondagem linear. Todos os elementos são armazenados diretamente no array da tabela, sem estruturas auxiliares. Implementa lazy deletion e controle automático de fator de carga para manter performance.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🏗️ Estrutura Celula</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <p class="text-gray-700 text-sm mb-2">Cada célula pode estar em três estados:</p>
                                <ul class="list-disc list-inside space-y-1 text-gray-700 text-sm">
                                    <li><strong>VAZIO:</strong> Nunca foi ocupada - para busca e permite inserção</li>
                                    <li><strong>OCUPADO:</strong> Contém um valor válido</li>
                                    <li><strong>REMOVIDO:</strong> Foi ocupada mas valor foi removido (lazy deletion)</li>
                                </ul>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">⚙️ Sondagem Linear</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                O método <code>sondagemLinear()</code> é o coração do endereçamento aberto. Incrementa sequencialmente o índice até encontrar posição adequada. Comporta-se diferentemente para inserção (procura VAZIO/REMOVIDO) e busca (para em VAZIO, continua em REMOVIDO).
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🎛️ Controle de Fator de Carga</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>MAX_FATOR_CARGA = 0.7:</strong> Limite para manter performance aceitável</li>
                                <li><strong>fatorCarga():</strong> Considera apenas elementos ativos (não removidos)</li>
                                <li><strong>fatorOcupacao():</strong> Inclui elementos removidos para decisão de rehash</li>
                                <li><strong>precisaRehash():</strong> Verifica se é necessário expandir a tabela</li>
                            </ul>
                            
                            <div class="code-block"><pre><code><span class="comment">// Estados possíveis de uma célula</span>
<span class="keyword">struct</span> Celula {
    <span class="keyword">enum</span> <span class="keyword">class</span> Estado { VAZIO, OCUPADO, REMOVIDO };
    
    <span class="type">int</span> valor;
    Estado estado;
    
    <span class="comment">// Construtor para célula vazia</span>
    Celula() : valor(<span class="number">0</span>), estado(Estado::VAZIO) {}
    
    <span class="comment">// Verifica se célula está disponível para inserção</span>
    <span class="type">bool</span> disponivelParaInsercao() <span class="keyword">const</span> {
        <span class="keyword">return</span> estado == Estado::VAZIO || estado == Estado::REMOVIDO;
    }
};

<span class="keyword">class</span> TabelaAberta {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;Celula&gt;</span> tabela;     <span class="comment">// Array único de células</span>
    <span class="type">size_t</span> numElementos;            <span class="comment">// Elementos ativos</span>
    <span class="type">size_t</span> numRemovidos;            <span class="comment">// Elementos removidos</span>
    
    <span class="comment">// Constantes para controle</span>
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> MAX_FATOR_CARGA = <span class="number">0.7</span>;
    
    <span class="comment">// Sondagem linear - coração do endereçamento aberto</span>
    <span class="type">size_t</span> sondagemLinear(<span class="type">size_t</span> indiceInicial, <span class="type">int</span> valor, <span class="type">bool</span> paraInsercao) <span class="keyword">const</span>;

<span class="keyword">public</span>:
    <span class="comment">// Lazy deletion - marca como removido sem reorganizar</span>
    <span class="type">std::optional&lt;int&gt;</span> remover(<span class="type">int</span> valor, TipoHash tipo);
    
    <span class="comment">// Controle de fator de carga</span>
    <span class="type">double</span> fatorCarga() <span class="keyword">const</span>;      <span class="comment">// Apenas elementos ativos</span>
    <span class="type">double</span> fatorOcupacao() <span class="keyword">const</span>;    <span class="comment">// Inclui removidos</span>
    <span class="type">bool</span> precisaRehash() <span class="keyword">const</span>;
};</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🎯 Vantagens do Endereçamento Aberto</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Maior eficiência de memória</strong> - sem ponteiros extras</li>
                                <li><strong>Melhor localidade de cache</strong> - dados contíguos</li>
                                <li><strong>Performance excelente</strong> com baixo fator de carga</li>
                                <li><strong>Menos alocações dinâmicas</strong></li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">⚠️ Desafios</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>Clustering primário</strong> - elementos tendem a se agrupar</li>
                                <li><strong>Performance degrada rapidamente</strong> com alto fator de carga</li>
                                <li><strong>Lazy deletion necessária</strong> para manter integridade da sondagem</li>
                            </ul>
                        </div>
                    </details>
                </article>

                <!-- CarregadorDados.hpp -->
                <article>
                    <details>
                        <summary><code>include/CarregadorDados.hpp</code> - Interface do Gerenciador de Datasets</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📋 Visão Geral</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Classe especializada no gerenciamento de datasets para os testes de tabelas hash. Sua função principal é <strong>carregar</strong> dados de arquivos na pasta <code>data/</code>, mas também oferece funcionalidades complementares como geração de dados aleatórios, validação de arquivos e análise estatística.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🎲 Sistema de Geração Aleatória</h4>
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <p class="text-gray-700 text-sm mb-2">Utiliza std::mt19937 (Mersenne Twister) para geração de alta qualidade:</p>
                                <ul class="list-disc list-inside space-y-1 text-gray-700 text-sm">
                                    <li><strong>Seed configurável:</strong> Permite reprodutibilidade ou aleatoriedade</li>
                                    <li><strong>Distribuição uniforme:</strong> std::uniform_int_distribution garante distribuição uniforme</li>
                                    <li><strong>Faixa ajustável:</strong> Valores entre 1 e 1.000.000 por padrão</li>
                                </ul>
                            </div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📁 Carregamento Robusto de Arquivos</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Formato flexível:</strong> Suporta arquivos com ou sem header de quantidade</li>
                                <li><strong>Tratamento de erros:</strong> Continua processamento mesmo com linhas inválidas</li>
                                <li><strong>Limpeza automática:</strong> Remove espaços em branco e linhas vazias</li>
                                <li><strong>Validação de integridade:</strong> Verifica consistência dos dados carregados</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📊 Análise Estatística</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                A estrutura <code>InfoDataset</code> encapsula informações completas sobre um dataset: quantidade de elementos, valores mínimo/máximo, média aritmética, análise de duplicatas. Essencial para caracterizar a qualidade dos dados de teste.
                            </p>
                            
                            <div class="code-block"><pre><code><span class="keyword">class</span> CarregadorDados {
<span class="keyword">private</span>:
    <span class="type">std::mt19937</span> gerador;                           <span class="comment">// Mersenne Twister</span>
    <span class="type">std::uniform_int_distribution&lt;int&gt;</span> distribuicao; <span class="comment">// Distribuição uniforme</span>
    
    <span class="comment">// Utilitários internos</span>
    <span class="type">bool</span> arquivoExiste(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
    <span class="type">std::string</span> trim(<span class="keyword">const</span> <span class="type">std::string</span>&amp; str) <span class="keyword">const</span>;

<span class="keyword">public</span>:
    <span class="comment">// Carregamento principal - função core</span>
    <span class="type">std::vector&lt;int&gt;</span> carregarDeArquivo(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
    
    <span class="comment">// Geração de dados para testes</span>
    <span class="type">std::vector&lt;int&gt;</span> gerarNumerosAleatorios(<span class="type">size_t</span> quantidade);           <span class="comment">// Únicos</span>
    <span class="type">std::vector&lt;int&gt;</span> gerarNumerosAleatoriosComRepeticao(<span class="type">size_t</span> quantidade); <span class="comment">// Permite duplicatas</span>
    
    <span class="comment">// Estrutura para análise de datasets</span>
    <span class="keyword">struct</span> InfoDataset {
        <span class="type">std::string</span> nomeArquivo;    <span class="comment">// Nome do arquivo</span>
        <span class="type">size_t</span> quantidade;          <span class="comment">// Número de elementos</span>
        <span class="type">int</span> minimo, maximo;         <span class="comment">// Faixa de valores</span>
        <span class="type">double</span> media;               <span class="comment">// Média aritmética</span>
        <span class="type">bool</span> temDuplicatas;         <span class="comment">// Se contém duplicatas</span>
        <span class="type">size_t</span> numDuplicatas;       <span class="comment">// Quantidade de duplicatas</span>
    };
    
    <span class="comment">// Análise e validação</span>
    InfoDataset analisarDataset(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
    <span class="type">bool</span> validarArquivo(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
    <span class="type">void</span> exibirEstatisticas(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
};</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🔧 Funcionalidades Auxiliares</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>gerarArquivosTrabalho():</strong> Cria automaticamente todos os datasets necessários (100 a 50.000)</li>
                                <li><strong>listarArquivosDisponiveis():</strong> Escaneia pasta data/ e lista arquivos .txt encontrados</li>
                                <li><strong>salvarEmArquivo():</strong> Persiste dados no formato padronizado do projeto</li>
                                <li><strong>BenchmarkCarregadorDados:</strong> Classe utilitária para testar performance das operações</li>
                            </ul>
                        </div>
                    </details>
                </article>
                
                <!-- Implementações .cpp -->
                <article>
                    <details>
                        <summary><code>src/*.cpp</code> - Arquivos de Implementação</summary>
                        <div class="details-content">
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📋 Visão Geral das Implementações</h4>
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Todos os arquivos .cpp contêm implementações completas e otimizadas dos métodos definidos nos headers correspondentes. Cada implementação inclui documentação detalhada, tratamento de erros, e otimizações específicas para máxima performance nos benchmarks.
                            </p>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🔍 TabelaEncadeada.cpp - Características Técnicas</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Inserção otimizada:</strong> Inserção no início das listas para O(1), com verificação de duplicatas</li>
                                <li><strong>Busca eficiente:</strong> Percorre lista sequencialmente até encontrar elemento ou nullptr</li>
                                <li><strong>Remoção robusta:</strong> Trata casos especiais (primeiro elemento vs. meio da lista)</li>
                                <li><strong>Estatísticas avançadas:</strong> Calcula distribuição, clustering, e colisões reais</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">⚡ TabelaAberta.cpp - Aspectos de Performance</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Sondagem linear otimizada:</strong> Algoritmo central que determina posições para inserção/busca</li>
                                <li><strong>Lazy deletion inteligente:</strong> Mantém integridade da sondagem sem reorganização custosa</li>
                                <li><strong>Análise de clustering:</strong> Detecta e mede agrupamentos primários automaticamente</li>
                                <li><strong>Controle preventivo:</strong> Monitora fator de carga para evitar degradação severa</li>
                            </ul>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">📈 CarregadorDados.cpp - Robustez e Flexibilidade</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4">
                                <li><strong>Parsing inteligente:</strong> Detecta automaticamente formato do arquivo (com/sem header)</li>
                                <li><strong>Recuperação de erros:</strong> Continua processamento mesmo com linhas corrompidas</li>
                                <li><strong>Geração eficiente:</strong> Algoritmos otimizados para datasets grandes</li>
                                <li><strong>Análise estatística completa:</strong> Calcula métricas descritivas usando algoritmos numericamente estáveis</li>
                            </ul>
                            
                            <div class="code-block"><pre><code><span class="comment">// Exemplo: Inserção otimizada na tabela encadeada</span>
<span class="type">void</span> TabelaEncadeada::inserir(<span class="type">int</span> valor, TipoHash tipo) {
    <span class="comment">// 1. Calcula índice usando função hash especificada</span>
    <span class="type">size_t</span> indice = (tipo == TipoHash::DIVISAO) 
        ? calcularHashDivisao(valor) 
        : calcularHashMultiplicacao(valor);
    
    <span class="comment">// 2. Verifica duplicatas (importante para integridade)</span>
    <span class="keyword">if</span> (buscar(valor, tipo)) {
        <span class="keyword">return</span>; <span class="comment">// Elemento já existe</span>
    }
    
    <span class="comment">// 3. Inserção no início (O(1)) usando ponteiros inteligentes</span>
    <span class="keyword">auto</span> novoNo = <span class="type">std::make_unique&lt;No&gt;</span>(valor);
    novoNo-&gt;proximo = <span class="type">std::move</span>(tabela[indice]);
    tabela[indice] = <span class="type">std::move</span>(novoNo);
    
    ++numElementos;
}

<span class="comment">// Exemplo: Sondagem linear na tabela aberta</span>
<span class="type">size_t</span> TabelaAberta::sondagemLinear(<span class="type">size_t</span> indiceInicial, <span class="type">int</span> valor, <span class="type">bool</span> paraInsercao) <span class="keyword">const</span> {
    <span class="type">size_t</span> tentativas = <span class="number">0</span>;
    <span class="type">size_t</span> indice = indiceInicial;
    
    <span class="keyword">while</span> (tentativas &lt; tamanho) {
        <span class="keyword">const</span> Celula&amp; celula = tabela[indice];
        
        <span class="keyword">if</span> (paraInsercao) {
            <span class="comment">// Para inserção: aceita VAZIO ou REMOVIDO</span>
            <span class="keyword">if</span> (celula.disponivelParaInsercao()) <span class="keyword">return</span> indice;
        } <span class="keyword">else</span> {
            <span class="comment">// Para busca: para em VAZIO, continua em REMOVIDO</span>
            <span class="keyword">if</span> (celula.estado == Celula::Estado::VAZIO) <span class="keyword">return</span> tamanho;
            <span class="keyword">if</span> (celula.estado == Celula::Estado::OCUPADO &amp;&amp; celula.valor == valor) {
                <span class="keyword">return</span> indice;
            }
        }
        
        <span class="comment">// Avança circularmente</span>
        indice = (indice + <span class="number">1</span>) % tamanho;
        ++tentativas;
    }
    
    <span class="keyword">return</span> tamanho; <span class="comment">// Não encontrou</span>
}</code></pre></div>
                            
                            <h4 class="text-lg font-semibold mb-3 text-gray-800">🏆 Padrões de Qualidade Implementados</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li><strong>Documentação Doxygen completa</strong> com descrições detalhadas de complexidade</li>
                                <li><strong>Tratamento robusto de exceções</strong> com mensagens informativas</li>
                                <li><strong>Uso consistente de C++17</strong> com smart pointers e containers STL</li>
                                <li><strong>Otimizações de performance</strong> específicas para benchmarking</li>
                                <li><strong>Código defensivo</strong> com validações de entrada e estados</li>
                            </ul>
                        </div>
                    </details>
                </article>
            </div>
        </section>

        <!-- Resultados e Gráficos -->
        <section id="graficos" class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">4. Resultados e Gráficos</h2>
            <p class="mb-6 text-gray-700">
                Os gráficos abaixo apresentam uma análise visual do desempenho das diferentes implementações de tabela hash. Use os filtros para comparar os cenários e clique no botão para baixar uma imagem do gráfico.
            </p>

            <!-- Controles do Gráfico -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 p-4 bg-gray-50 rounded-lg border">
                <div>
                    <label for="chartType" class="block text-sm font-medium text-gray-700">Métrica de Análise:</label>
                    <select id="chartType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="insertion" selected>Tempo de Inserção (ms)</option>
                        <option value="search">Tempo de Busca (ms)</option>
                        <option value="collisions">Colisões</option>
                    </select>
                </div>
                <div>
                    <label for="tableType" class="block text-sm font-medium text-gray-700">Tipo de Tabela Hash:</label>
                    <select id="tableType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Encadeada">Encadeada</option>
                        <option value="Aberta">Aberta</option>
                    </select>
                </div>
                 <div>
                    <label for="hashFunction" class="block text-sm font-medium text-gray-700">Função de Hash:</label>
                    <select id="hashFunction" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Divisao">Divisão</option>
                        <option value="Multiplicacao">Multiplicação</option>
                    </select>
                </div>
            </div>

            <!-- Container do Gráfico -->
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
            <div class="text-center mt-4">
                <button id="downloadChartBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-300">
                    Baixar Gráfico
                </button>
            </div>
        </section>

         <!-- Conclusão -->
        <section id="conclusao" class="mt-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">5. Conclusão</h2>
            <p class="text-gray-700 leading-relaxed">
                A análise comparativa revelou insights importantes sobre o comportamento das diferentes estratégias de hashing. A <strong>TabelaEncadeada</strong> demonstrou ser mais robusta e previsível, especialmente em cenários com alto fator de carga, onde o desempenho de inserção e busca degrada de forma mais suave. Embora possa consumir mais memória devido às listas, sua performance é menos sensível à qualidade da função de hash.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                Por outro lado, a <strong>TabelaAberta</strong> se mostrou extremamente eficiente em cenários de baixo fator de carga, superando a versão encadeada devido à melhor localidade de cache e menor sobrecarga de alocação de memória. No entanto, seu desempenho decai drasticamente à medida que a tabela se aproxima de sua capacidade máxima, tornando-a inadequada para cenários onde o número de elementos é próximo ao tamanho da tabela.
            </p>
             <p class="text-gray-700 leading-relaxed mt-4">
                Entre as funções de hash, não houve um vencedor claro em todos os cenários, mas a função de <strong>divisão</strong> apresentou, em média, uma distribuição ligeiramente melhor e menos colisões, principalmente para a tabela de endereçamento aberto. A escolha da abordagem ideal depende, portanto, dos requisitos específicos da aplicação, como a previsibilidade do número de elementos, as restrições de memória e a performance desejada.
            </p>
        </section>

    </main>

    <footer class="bg-white mt-12">
        <div class="container mx-auto px-6 py-4 text-center text-gray-500">
            <p>Desenvolvido para a disciplina de Pesquisa e Ordenação.</p>
        </div>
    </footer>

    <script>
        // Data from resultados_benchmark.csv
        const csvData = `TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga
Encadeada,29,100,Divisao,0.010,0.018,71,3.4483
Encadeada,29,100,Multiplicacao,0.009,0.028,71,3.4483
Encadeada,97,100,Divisao,0.008,0.014,37,1.0309
Encadeada,97,100,Multiplicacao,0.008,0.023,37,1.0309
Encadeada,251,100,Divisao,0.006,0.014,0,0.3984
Encadeada,251,100,Multiplicacao,0.005,0.013,0,0.3984
Encadeada,499,100,Divisao,0.009,0.007,0,0.2004
Encadeada,499,100,Multiplicacao,0.006,0.012,0,0.2004
Encadeada,911,100,Divisao,0.007,0.005,0,0.1098
Encadeada,911,100,Multiplicacao,0.007,0.006,0,0.1098
Aberta,101,100,Divisao,0.007,0.004,50,0.9901
Aberta,101,100,Multiplicacao,0.007,0.004,50,0.9901
Aberta,251,100,Divisao,0.005,0.003,0,0.3984
Aberta,251,100,Multiplicacao,0.006,0.003,0,0.3984
Aberta,499,100,Divisao,0.006,0.002,0,0.2004
Aberta,499,100,Multiplicacao,0.006,0.003,0,0.2004
Aberta,911,100,Divisao,0.006,0.003,0,0.1098
Aberta,911,100,Multiplicacao,0.006,0.003,0,0.1098
Encadeada,29,500,Divisao,0.100,0.279,471,17.2414
Encadeada,29,500,Multiplicacao,0.086,0.258,471,17.2414
Encadeada,97,500,Divisao,0.049,0.119,403,5.1546
Encadeada,97,500,Multiplicacao,0.053,0.103,403,5.1546
Encadeada,251,500,Divisao,0.035,0.057,249,1.9920
Encadeada,251,500,Multiplicacao,0.037,0.051,249,1.9920
Encadeada,499,500,Divisao,0.030,0.024,1,0.0020
Encadeada,499,500,Multiplicacao,0.031,0.027,1,0.0020
Encadeada,911,500,Divisao,0.028,0.015,0,0.5488
Encadeada,911,500,Multiplicacao,0.028,0.019,0,0.5488
Aberta,503,500,Divisao,0.031,0.015,249,0.9940
Aberta,503,500,Multiplicacao,0.032,0.015,249,0.9940
Aberta,911,500,Divisao,0.028,0.012,0,0.5488
Aberta,911,500,Multiplicacao,0.029,0.014,0,0.5488
Encadeada,29,1000,Divisao,0.284,0.767,971,34.4828
Encadeada,29,1000,Multiplicacao,0.297,0.911,971,34.4828
Encadeada,97,1000,Divisao,0.119,0.287,903,10.3093
Encadeada,97,1000,Multiplicacao,0.115,0.263,903,10.3093
Encadeada,251,1000,Divisao,0.076,0.123,749,3.9841
Encadeada,251,1000,Multiplicacao,0.076,0.111,749,3.9841
Encadeada,499,1000,Divisao,0.063,0.059,501,2.0040
Encadeada,499,1000,Multiplicacao,0.066,0.060,501,2.0040
Encadeada,911,1000,Divisao,0.058,0.032,89,1.0977
Encadeada,911,1000,Multiplicacao,0.057,0.035,89,1.0977
Aberta,1009,1000,Divisao,0.057,0.028,496,0.9911
Aberta,1009,1000,Multiplicacao,0.062,0.030,496,0.9911
Encadeada,29,5000,Divisao,4.329,8.514,4971,172.4138
Encadeada,29,5000,Multiplicacao,4.551,9.088,4971,172.4138
Encadeada,97,5000,Divisao,1.442,3.159,4903,51.5464
Encadeada,97,5000,Multiplicacao,1.558,3.226,4903,51.5464
Encadeada,251,5000,Divisao,0.592,1.011,4750,19.9203
Encadeada,251,5000,Multiplicacao,0.594,0.932,4750,19.9203
Encadeada,499,5000,Divisao,0.379,0.510,4501,10.0200
Encadeada,499,5000,Multiplicacao,0.395,0.479,4501,10.0200
Encadeada,911,5000,Divisao,0.292,0.252,4089,5.4885
Encadeada,911,5000,Multiplicacao,0.291,0.254,4089,5.4885
Aberta,5003,5000,Divisao,0.290,0.141,2493,0.9994
Aberta,5003,5000,Multiplicacao,0.312,0.155,2493,0.9994
Encadeada,29,10000,Divisao,10.647,1.779,9922,343.1379
Encadeada,29,10000,Multiplicacao,9.404,1.932,9922,343.1379
Encadeada,97,10000,Divisao,3.794,1.424,9854,102.5876
Encadeada,97,10000,Multiplicacao,3.483,0.541,9854,102.5876
Encadeada,251,10000,Divisao,1.358,0.195,9700,39.6454
Encadeada,251,10000,Multiplicacao,1.445,0.205,9700,39.6454
Encadeada,499,10000,Divisao,0.896,0.103,9500,20.0401
Encadeada,499,10000,Multiplicacao,0.875,0.102,9500,20.0401
Encadeada,911,10000,Divisao,0.618,0.061,9088,10.9769
Encadeada,911,10000,Multiplicacao,0.609,0.060,9088,10.9769
Aberta,10007,10000,Divisao,0.612,0.303,4992,0.9993
Aberta,10007,10000,Multiplicacao,0.627,0.320,4992,0.9993
Encadeada,29,50000,Divisao,315.341,833.111,49971,1724.1379
Encadeada,29,50000,Multiplicacao,305.981,852.179,49971,1724.1379
Encadeada,97,50000,Divisao,93.992,260.912,49903,515.4639
Encadeada,97,50000,Multiplicacao,97.388,272.871,49903,515.4639
Encadeada,251,50000,Divisao,36.561,91.879,49750,199.2032
Encadeada,251,50000,Multiplicacao,37.330,96.678,49750,199.2032
Encadeada,499,50000,Divisao,21.841,50.111,49501,100.2004
Encadeada,499,50000,Multiplicacao,22.251,52.288,49501,100.2004
Encadeada,911,50000,Divisao,13.790,29.332,49089,54.8847
Encadeada,911,50000,Multiplicacao,13.679,28.690,49089,54.8847
Aberta,50021,50000,Divisao,15.223,7.568,24982,0.9996
Aberta,50021,50000,Multiplicacao,15.178,7.741,24982,0.9996`;

        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const entry = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    entry[header] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                });
                return entry;
            });
        }

        const benchmarkData = parseCSV(csvData);
        let myChart;

        const chartConfig = {
            insertion: {
                label: 'Tempo de Inserção (ms)',
                key: 'TempoInsercao(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            search: {
                label: 'Tempo de Busca (ms)',
                key: 'TempoBusca(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            collisions: {
                label: 'Colisões',
                key: 'Colisoes',
                yAxisLabel: 'Número de Colisões'
            }
        };

        const colors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };
         const borderColors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };


        function updateChart() {
            const chartType = document.getElementById('chartType').value;
            const tableType = document.getElementById('tableType').value;
            const hashFunction = document.getElementById('hashFunction').value;

            const selectedConfig = chartConfig[chartType];

            let filteredData = benchmarkData;
            if (tableType !== 'all') {
                filteredData = filteredData.filter(d => d.TipoTabela === tableType);
            }
            if (hashFunction !== 'all') {
                filteredData = filteredData.filter(d => d.FuncaoHash === hashFunction);
            }
            
            const labels = [...new Set(filteredData.map(d => d.QuantidadeDados))].sort((a,b) => a - b);

            const datasets = [];
            const combinations = [...new Set(filteredData.map(d => `${d.TipoTabela}-${d.FuncaoHash}`))];;

            combinations.forEach(combo => {
                const [tipo, hash] = combo.split('-');
                
                const dataForCombo = filteredData.filter(d => d.TipoTabela === tipo && d.FuncaoHash === hash);
                
                // Agrupar por QuantidadeDados e pegar a média para evitar multiplos pontos
                const dataPoints = labels.map(label => {
                    const points = dataForCombo
                        .filter(d => d.QuantidadeDados === label)
                        .map(d => d[selectedConfig.key]);
                    return points.length > 0 ? points.reduce((a, b) => a + b, 0) / points.length : null;
                });
                
                datasets.push({
                    label: `${tipo} - ${hash}`,
                    data: dataPoints,
                    borderColor: borderColors[combo],
                    backgroundColor: colors[combo].replace('1)', '0.2)'),
                    fill: false,
                    tension: 0.1
                });
            });


            const ctx = document.getElementById('benchmarkChart').getContext('2d');
            if (myChart) {
                myChart.destroy();
            }
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectedConfig.label} vs. Quantidade de Dados`,
                            font: { size: 18 }
                        },
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Quantidade de Dados Inseridos'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: selectedConfig.yAxisLabel
                            },
                             type: 'logarithmic',
                             ticks: {
                                callback: function(value, index, values) {
                                    if (value >= 1000) {
                                        return value.toExponential();
                                    }
                                    return Number(value.toString());
                                }
                            }
                        }
                    }
                }
            });
        }

        document.getElementById('chartType').addEventListener('change', updateChart);
        document.getElementById('tableType').addEventListener('change', updateChart);
        document.getElementById('hashFunction').addEventListener('change', updateChart);
        
        document.getElementById('downloadChartBtn').addEventListener('click', () => {
            const chartCanvas = document.getElementById('benchmarkChart');
            const url = chartCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = url;
            link.download = `grafico_benchmark_${new Date().getTime()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initial chart render
        window.addEventListener('load', updateChart);

    </script>
</body>
</html>