<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Análise Comparativa de Tabelas Hash</title>
  <meta name="description" content="Implementação e análise comparativa de soluções baseadas em hashing (C++17): listas encadeadas vs endereçamento aberto; funções hash: divisão e multiplicação." />
  <style>
    :root { --bg:#0b1220; --card:#111a2e; --muted:#a9b4c9; --text:#eaf0ff; --acc:#4da3ff; --acc2:#22c55e; }
    *{box-sizing:border-box; margin:0; padding:0}
    body{background:linear-gradient(180deg,#0b1220,#0c1426 40%,#0b1323);color:var(--text);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    a{color:var(--acc);text-decoration:none}
    header{position:sticky;top:0;z-index:10;background:rgba(11,18,32,.9);backdrop-filter:blur(10px);border-bottom:1px solid #1e2a44}
    .nav{max-width:1200px;margin:auto;display:flex;gap:16px;align-items:center;justify-content:space-between;padding:12px 20px}
    .brand{display:flex;gap:10px;align-items:center}
    .brand h1{font-size:18px}
    .menu{display:flex;gap:16px;flex-wrap:wrap}
    .menu a{padding:8px 12px;border-radius:6px;transition:background .2s}
    .menu a:hover{background:rgba(77,163,255,.1)}
    .container{max-width:1200px;margin:auto;padding:30px 20px}
    .section{margin-bottom:40px;background:var(--card);border:1px solid #203052;border-radius:12px;padding:24px}
    h2{font-size:28px;margin-bottom:16px;color:#e0f2ff}
    h3{font-size:22px;margin:24px 0 12px;color:#cfe3ff}
    h4{font-size:18px;margin:20px 0 8px;color:#b8d5ff}
    .twocol{display:grid;grid-template-columns:1.2fr .8fr;gap:20px;margin-bottom:20px}
    @media (max-width:900px){.twocol{grid-template-columns:1fr}}
    .muted{color:var(--muted)}
    .tag{display:inline-block;margin:0 6px 6px 0;padding:4px 10px;border:1px solid #28436a;border-radius:20px;color:#bcd5ff;font-size:13px}
    .btn{display:inline-flex;align-items:center;gap:8px;background:linear-gradient(90deg,#2563eb,#0ea5e9);border:none;padding:12px 18px;border-radius:8px;color:#fff;font-weight:600;text-decoration:none;transition:transform .2s}
    .btn:hover{transform:translateY(-2px)}
    pre{background:#0d162b;border:1px solid #1d2a49;border-radius:8px;padding:16px;overflow-x:auto;margin:12px 0}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;color:#e2e8f0}
    .chart-container{background:#0f1b35;border:1px solid #1d2a49;border-radius:8px;padding:16px;margin:16px 0}
    .chart{width:100%;height:400px !important;min-height:400px}
    .footer{border-top:1px solid #1e2a44;margin-top:40px;padding-top:20px;color:#9db0d4;text-align:center}
    .code-section{margin:20px 0}
    .code-section h4{margin-bottom:8px}
    .explanation{background:#0a1528;border-left:4px solid #4da3ff;padding:12px 16px;margin:10px 0;border-radius:0 6px 6px 0}
    ul li{margin:6px 0}
    /* Prism theme */
    .token.comment{color:#7c7c7c !important}
    .token.keyword{color:#93c5fd !important}
    .token.string{color:#86efac !important}
    .token.function{color:#fbbf24 !important}
    .token.number{color:#fcd34d !important}
    .token.operator{color:#f8fafc !important}
    .token.punctuation{color:#cbd5e1 !important}
    .token.class-name{color:#f472b6 !important}
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <header>
    <div class="nav">
      <div class="brand">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M4 6h16M4 12h10M4 18h16" stroke="#9cc6ff" stroke-width="2" stroke-linecap="round"/></svg>
        <h1>Análise Comparativa de Tabelas Hash</h1>
      </div>
      <nav class="menu">
        <a href="#intro">Introdução</a>
        <a href="#metodologia">Metodologia</a>
        <a href="#implementacao">Implementação</a>
        <a href="#resultados">Resultados</a>
        <a href="#discussao">Discussão</a>
        <a href="#conclusao">Conclusão</a>
        <a href="https://github.com/Gabriel-Freitas-S/analise_hash" target="_blank">Repositório</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <section id="intro" class="section">
      <div class="twocol">
        <div>
          <h2>Introdução</h2>
          <p>Este trabalho implementa e compara duas estratégias de tratamento de colisões em tabelas hash — <b>listas encadeadas</b> (chaining) e <b>endereçamento aberto</b> (sondagem linear) — aliadas a duas funções de hashing: <b>divisão</b> e <b>multiplicação</b>. O estudo quantifica <b>tempo de inserção</b>, <b>tempo de busca</b>, <b>colisões</b> e <b>fator de carga</b> com datasets de 100 a 50.000 elementos, em C++17.</p>
          <div>
            <span class="tag">C++17</span>
            <span class="tag">Encadeamento</span>
            <span class="tag">Endereçamento Aberto</span>
            <span class="tag">Divisão</span>
            <span class="tag">Multiplicação</span>
            <span class="tag">Benchmarks</span>
          </div>
        </div>
        <div style="background:var(--card);border:1px solid #203052;border-radius:8px;padding:16px">
          <h3>Funções Hash</h3>
          <p class="muted"><b>Divisão:</b> h(k) = k mod p</p>
          <p class="muted"><b>Multiplicação:</b> h(k) = ⌊ frac(k×c) × p ⌋, com c ≈ 0,618</p>
          <p class="muted">Para encadeamento, tamanhos <i>primos</i> (29, 97, 251, 499, 911) favorecem distribuição; para aberto, tabela fixa 50.009.</p>
        </div>
      </div>
    </section>

    <section id="metodologia" class="section">
      <h2>Metodologia</h2>
      <p>Os experimentos inserem e buscam inteiros provenientes de arquivos de dados, medindo tempos com relógio de alta resolução. Para cada dataset, testamos <b>encadeamento</b> com cinco tamanhos de tabela e <b>endereçamento aberto</b> com tamanho fixo. Os arquivos de 100 a 50.000 elementos foram usados, e 1.000 números aleatórios (com repetição) serviram para as buscas.</p>
      <ul>
        <li><b>Métricas:</b> Tempo de Inserção (ms), Tempo de Busca (ms), Colisões, Fator de Carga</li>
        <li><b>Dados:</b> resultados_benchmark.csv gerado pelo programa</li>
        <li><b>Medição:</b> std::chrono::high_resolution_clock para precisão</li>
      </ul>
    </section>

    <section id="implementacao" class="section">
      <h2>Implementação</h2>
      
      <h3>Estrutura do Projeto</h3>
      <pre><code class="language-bash">analise_hash/
├── include/                  # Cabeçalhos (.hpp)
│   ├── TabelaHashEncadeada.hpp
│   ├── TabelaHashAberta.hpp
│   └── GeradorDados.hpp
├── src/                     # Implementações (.cpp)
│   ├── main.cpp
│   ├── TabelaHashEncadeada.cpp
│   ├── TabelaHashAberta.cpp
│   └── GeradorDados.cpp
├── data/                    # Datasets
│   ├── numeros_aleatorios_100.txt
│   └── ... (até 50.000 elementos)
├── resultados_benchmark.csv
├── index.html
└── CMakeLists.txt</code></pre>

      <div class="code-section">
        <h3>TabelaHashEncadeada.hpp/.cpp</h3>
        <div class="explanation">
          <p><b>Propósito:</b> Define e implementa a tabela hash com encadeamento. Cada posição armazena uma lista encadeada de colisões. Evita duplicatas, calcula fator de carga e provê estatísticas de distribuição.</p>
        </div>
        
        <h4>Estrutura do Nó</h4>
        <pre><code class="language-cpp">struct No {
  int valor;                           // Valor armazenado
  std::unique_ptr&lt;No&gt; proximo;        // Próximo elemento na lista
  explicit No(int val) : valor(val), proximo(nullptr) {}
};</code></pre>
        <div class="explanation">
          <p><b>Memória:</b> <code>unique_ptr</code> elimina necessidade de <code>delete</code>, evitando vazamentos. Listas são desalocadas automaticamente.</p>
        </div>

        <h4>Funções de Hash</h4>
        <pre><code class="language-cpp">// Divisão (usa números primos para melhor distribuição)
size_t calcularHashDivisao(int chave) const {
  return static_cast&lt;size_t&gt;(std::abs(chave)) % tamanho;
}
// Multiplicação (fração áurea)
size_t calcularHashMultiplicacao(int chave) const {
  double prod = std::abs(chave) * 0.6180339887;
  double frac = prod - std::floor(prod);
  return static_cast&lt;size_t&gt;(std::floor(frac * tamanho));
}</code></pre>

        <h4>Inserção, Busca e Remoção</h4>
        <pre><code class="language-cpp">void inserir(int valor, TipoHash tipo) {
  size_t i = (tipo == TipoHash::DIVISAO) ? calcularHashDivisao(valor)
                                         : calcularHashMultiplicacao(valor);
  if (buscar(valor, tipo)) return;           // evita duplicata
  auto novo = std::make_unique&lt;No&gt;(valor);
  novo-&gt;proximo = std::move(tabela[i]);      // insere na cabeça (O(1))
  tabela[i] = std::move(novo);
  ++numElementos;
}

bool buscar(int valor, TipoHash tipo) const {
  size_t i = (tipo == TipoHash::DIVISAO) ? calcularHashDivisao(valor)
                                         : calcularHashMultiplicacao(valor);
  for (const No* p = tabela[i].get(); p; p = p-&gt;proximo.get()) {
    if (p-&gt;valor == valor) return true;
  }
  return false;
}

bool remover(int valor, TipoHash tipo) {
  size_t i = (tipo == TipoHash::DIVISAO) ? calcularHashDivisao(valor)
                                         : calcularHashMultiplicacao(valor);
  if (tabela[i] && tabela[i]-&gt;valor == valor) {          // caso cabeça
    tabela[i] = std::move(tabela[i]-&gt;proximo);
    --numElementos; return true;
  }
  for (No* p = tabela[i].get(); p && p-&gt;proximo; p = p-&gt;proximo.get()) {
    if (p-&gt;proximo-&gt;valor == valor) {
      p-&gt;proximo = std::move(p-&gt;proximo-&gt;proximo);
      --numElementos; return true;
    }
  }
  return false;
}</code></pre>
        <div class="explanation">
          <p><b>Complexidade Média:</b> Inserção O(1), busca/remoção O(1) amortizado. No pior caso (muitas colisões), O(n) por posição.</p>
        </div>
      </div>

      <div class="code-section">
        <h3>TabelaHashAberta.hpp/.cpp</h3>
        <div class="explanation">
          <p><b>Propósito:</b> Implementa endereçamento aberto com <b>sondagem linear</b>, <b>lazy deletion</b> e limites de fator de carga. Mede sondagens e clustering.</p>
        </div>

        <h4>Estados da Célula</h4>
        <pre><code class="language-cpp">struct Celula {
  enum class Estado { VAZIO, OCUPADO, REMOVIDO };
  int valor; Estado estado;
  Celula() : valor(0), estado(Estado::VAZIO) {}
  explicit Celula(int val) : valor(val), estado(Estado::OCUPADO) {}
  bool disponivelParaInsercao() const { return estado != Estado::OCUPADO; }
};</code></pre>

        <h4>Sondagem Linear e Inserção</h4>
        <pre><code class="language-cpp">size_t sondagemLinear(size_t idx0, int valor, bool paraInsercao) const {
  size_t tent = 0, i = idx0;
  while (tent &lt; tamanho) {
    const Celula &c = tabela[i];
    if (paraInsercao) {
      if (c.disponivelParaInsercao()) return i;              // VAZIO ou REMOVIDO
      if (c.estado == Celula::Estado::OCUPADO && c.valor == valor) return i; // duplicata
    } else {
      if (c.estado == Celula::Estado::VAZIO) return tamanho; // não existe
      if (c.estado == Celula::Estado::OCUPADO && c.valor == valor) return i; // achou
    }
    i = (i + 1) % tamanho; ++tent;
  }
  return tamanho; // não encontrou
}

void inserir(int valor, TipoHash tipo) {
  if (precisaRehash()) throw std::runtime_error("Fator de carga alto: rehash necessário");
  size_t h = (tipo == TipoHash::DIVISAO) ? calcularHashDivisao(valor)
                                         : calcularHashMultiplicacao(valor);
  size_t i = sondagemLinear(h, valor, true);
  if (i &gt;= tamanho) throw std::runtime_error("Tabela cheia");
  if (tabela[i].estado == Celula::Estado::OCUPADO && tabela[i].valor == valor) return; // duplicata
  if (tabela[i].estado == Celula::Estado::REMOVIDO) --numRemovidos;
  tabela[i] = Celula(valor); ++numElementos;
}</code></pre>
        <div class="explanation">
          <p><b>Rehash:</b> A classe expõe <code>precisaRehash()</code> quando <i>fator de carga</i> ou <i>ocupação</i> ultrapassam limites configurados, preservando a performance média O(1).</p>
        </div>
      </div>

      <div class="code-section">
        <h3>GeradorDados.hpp/.cpp</h3>
        <div class="explanation">
          <p><b>Propósito:</b> Carrega arquivos existentes, gera números aleatórios (com/sem repetição), valida formato e estatísticas, e escreve relatórios (incluindo o CSV consolidado).</p>
        </div>
        <pre><code class="language-cpp">// Assinaturas principais
std::vector&lt;int&gt; carregarDeArquivo(const std::string &nomeArquivo);
std::vector&lt;int&gt; gerarNumerosAleatorios(size_t quantidade);
std::vector&lt;int&gt; gerarNumerosAleatoriosComRepeticao(size_t quantidade);
bool salvarEmArquivo(const std::vector&lt;int&gt;&numeros, const std::string &nomeArquivo);
GeradorDados::InfoDataset analisarDataset(const std::string &nomeArquivo);
</code></pre>
      </div>

      <div class="code-section">
        <h3>main.cpp</h3>
        <div class="explanation">
          <p><b>Responsável:</b> Orquestra benchmarks, mede tempos, calcula colisões e fator de carga, imprime relatório e salva <code>resultados_benchmark.csv</code>.</p>
        </div>
        <pre><code class="language-cpp">template&lt;typename Func&gt; double medirTempo(Func &amp;&amp;f);
void testarTabelaEncadeada(...);
void testarTabelaAberta(...);
void salvarResultados(const std::string &arquivo);
</code></pre>
      </div>
    </section>

    <section id="resultados" class="section">
      <h2>Resultados</h2>
      
      <div class="chart-container">
        <h3>Comparação de Tempo de Inserção</h3>
        <canvas id="g_insercao" class="chart"></canvas>
      </div>
      
      <div class="chart-container">
        <h3>Comparação de Tempo de Busca</h3>
        <canvas id="g_busca" class="chart"></canvas>
      </div>
      
      <div class="chart-container">
        <h3>Comparação de Funções Hash (Inserção)</h3>
        <canvas id="g_funcoes" class="chart"></canvas>
      </div>
      
      <div class="chart-container">
        <h3>Relação Fator de Carga × Colisões</h3>
        <canvas id="g_carga_colisao" class="chart"></canvas>
      </div>
      
      <div class="chart-container">
        <h3>Clustering e Sondagem — Tabela Aberta</h3>
        <canvas id="g_aberta_cluster" class="chart"></canvas>
      </div>
      
      <p class="muted">Fonte: dados empíricos do arquivo <code>resultados_benchmark.csv</code> gerado pela aplicação C++.</p>
    </section>

    <section id="discussao" class="section">
      <h2>Discussão</h2>
      <p><b>Encadeamento</b> apresenta estabilidade mesmo com alto fator de carga, à custa de memória adicional para ponteiros das listas. <b>Endereçamento aberto</b> é eficiente em espaço, mas sofre com <i>clustering</i> e degradação de performance com fatores de carga elevados, exigindo estratégias de rehash.</p>
      <p>A função de <b>divisão</b> tendeu a ser mais rápida nos testes práticos, enquanto a de <b>multiplicação</b> oferece distribuição teórica mais uniforme, especialmente independente do tamanho da tabela.</p>
    </section>

    <section id="conclusao" class="section">
      <h2>Conclusão</h2>
      <p>As duas estratégias são viáveis em diferentes cenários: para cargas altas e inserções intensivas, o <b>encadeamento</b> manteve tempos competitivos e previsíveis; para economia de espaço e consultas rápidas em baixas cargas, o <b>endereçamento aberto</b> se mostrou atrativo.</p>
      <p>Controlar o <b>fator de carga</b> é determinante para a performance, especialmente em endereçamento aberto. A escolha ótima depende do perfil de uso, da política de rehash e do tamanho esperado da tabela.</p>
      <a class="btn" href="https://github.com/Gabriel-Freitas-S/analise_hash" target="_blank">Ver Repositório Completo</a>
    </section>

    <div class="footer">
      <p><b>Autores:</b> <a href="https://github.com/Gabriel-Freitas-S" target="_blank">Gabriel Freitas Souza</a> e <a href="https://github.com/RoberliSchuina" target="_blank">Roberli Schuina Silva</a></p>
      <p><b>Disciplina:</b> Pesquisa e Ordenação • <b>Linguagem:</b> C++17 • <b>Ano:</b> 2025</p>
    </div>
  </main>

  <script>
  // CSV inline com fallback para GitHub Pages
  const CSV_INLINE = `TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga
Encadeada,29,100,Divisao,0.010,0.018,71,3.4483
Encadeada,29,100,Multiplicacao,0.009,0.028,71,3.4483
Encadeada,97,100,Divisao,0.008,0.014,37,1.0309
Encadeada,97,100,Multiplicacao,0.008,0.023,37,1.0309
Encadeada,251,100,Divisao,0.006,0.014,0,0.3984
Encadeada,251,100,Multiplicacao,0.005,0.013,0,0.3984
Encadeada,499,100,Divisao,0.009,0.007,0,0.2004
Encadeada,499,100,Multiplicacao,0.006,0.012,0,0.2004
Encadeada,911,100,Divisao,0.007,0.005,0,0.1098
Encadeada,911,100,Multiplicacao,0.006,0.010,0,0.1098
Aberta,50009,100,Divisao,0.012,0.005,0,0.0020
Aberta,50009,100,Multiplicacao,0.001,0.007,0,0.0020
Encadeada,29,500,Divisao,0.044,0.035,470,17.2069
Encadeada,29,500,Multiplicacao,0.051,0.048,470,17.2069
Encadeada,97,500,Divisao,0.060,0.031,402,5.1443
Encadeada,97,500,Multiplicacao,0.060,0.047,402,5.1443
Encadeada,251,500,Divisao,0.027,0.013,282,1.9880
Encadeada,251,500,Multiplicacao,0.041,0.023,282,1.9880
Encadeada,499,500,Divisao,0.026,0.011,0,1.0000
Encadeada,499,500,Multiplicacao,0.026,0.019,0,1.0000
Encadeada,911,500,Divisao,0.029,0.010,0,0.5477
Encadeada,911,500,Multiplicacao,0.030,0.016,0,0.5477
Aberta,50009,499,Divisao,0.004,0.004,2,0.0100
Aberta,50009,499,Multiplicacao,0.007,0.009,2,0.0100
Encadeada,29,1000,Divisao,0.099,0.054,971,34.4828
Encadeada,29,1000,Multiplicacao,0.077,0.070,971,34.4828
Encadeada,97,1000,Divisao,0.070,0.030,903,10.3093
Encadeada,97,1000,Multiplicacao,0.101,0.045,903,10.3093
Encadeada,251,1000,Divisao,0.063,0.017,753,3.9841
Encadeada,251,1000,Multiplicacao,0.067,0.025,753,3.9841
Encadeada,499,1000,Divisao,0.065,0.016,568,2.0040
Encadeada,499,1000,Multiplicacao,0.080,0.034,568,2.0040
Encadeada,911,1000,Divisao,0.039,0.011,392,1.0977
Encadeada,911,1000,Multiplicacao,0.046,0.021,392,1.0977
Aberta,50009,1000,Divisao,0.004,0.002,9,0.0200
Aberta,50009,1000,Multiplicacao,0.015,0.005,9,0.0200
Encadeada,29,5000,Divisao,1.996,0.782,4958,171.9655
Encadeada,29,5000,Multiplicacao,1.802,0.709,4958,171.9655
Encadeada,97,5000,Divisao,0.757,0.252,4890,51.4124
Encadeada,97,5000,Multiplicacao,0.780,0.228,4890,51.4124
Encadeada,251,5000,Divisao,0.446,0.076,4736,19.8685
Encadeada,251,5000,Multiplicacao,0.501,0.084,4736,19.8685
Encadeada,499,5000,Divisao,0.360,0.039,4488,9.9940
Encadeada,499,5000,Multiplicacao,0.422,0.050,4488,9.9940
Encadeada,911,5000,Divisao,0.311,0.027,4079,5.4742
Encadeada,911,5000,Multiplicacao,0.351,0.042,4079,5.4742
Aberta,50009,4987,Divisao,0.050,0.005,248,0.0997
Aberta,50009,4987,Multiplicacao,0.164,0.013,248,0.0997
Encadeada,29,10000,Divisao,10.647,1.779,9922,343.1379
Encadeada,29,10000,Multiplicacao,9.404,1.932,9922,343.1379
Encadeada,97,10000,Divisao,3.794,1.424,9854,102.5876
Encadeada,97,10000,Multiplicacao,3.483,0.541,9854,102.5876
Encadeada,251,10000,Divisao,1.358,0.195,9700,39.6454
Encadeada,251,10000,Multiplicacao,1.445,0.205,9700,39.6454
Encadeada,499,10000,Divisao,0.896,0.080,9452,19.9419
Encadeada,499,10000,Multiplicacao,0.931,0.078,9452,19.9419
Encadeada,911,10000,Divisao,0.647,0.038,9040,10.9232
Encadeada,911,10000,Multiplicacao,0.978,0.048,9040,10.9232
Aberta,50009,9951,Divisao,0.054,0.006,990,0.1990
Aberta,50009,9951,Multiplicacao,0.087,0.009,990,0.1990
Encadeada,29,50000,Divisao,249.355,10.696,48723,1681.1034
Encadeada,29,50000,Multiplicacao,216.560,10.778,48723,1681.1034
Encadeada,97,50000,Divisao,73.418,3.616,48655,502.5979
Encadeada,97,50000,Multiplicacao,75.745,3.505,48655,502.5979
Encadeada,251,50000,Divisao,33.389,2.266,48501,194.2311
Encadeada,251,50000,Multiplicacao,37.609,1.819,48501,194.2311
Encadeada,499,50000,Divisao,19.196,0.810,48253,97.6994
Encadeada,499,50000,Multiplicacao,20.494,0.681,48253,97.6994
Encadeada,911,50000,Divisao,11.557,0.389,47841,53.5148
Encadeada,911,50000,Multiplicacao,11.549,0.468,47841,53.5148
Aberta,50009,25005,Divisao,0.324,0.016,6251,0.5000
Aberta,50009,25005,Multiplicacao,0.355,0.024,6251,0.5000`;

  async function carregarCSV(){
    try {
      const resp = await fetch('resultados_benchmark.csv', {cache:'no-store'});
      if (!resp.ok) throw new Error('fetch falhou');
      const text = await resp.text();
      if (!text || text.indexOf('TipoTabela') !== 0) throw new Error('conteúdo inesperado');
      return parseCSV(text);
    } catch (e) {
      console.warn('Usando dados inline:', e.message);
      return parseCSV(CSV_INLINE);
    }
  }

  function parseCSV(text){
    const linhas = text.trim().split(/\r?\n/);
    linhas.shift(); // Remove header
    return linhas.map(l => {
      const c = l.split(',');
      return {
        TipoTabela: c[0], TamanhoTabela: +c[1], QuantidadeDados: +c[2], FuncaoHash: c[3],
        TempoInsercao: +c[4], TempoBusca: +c[5], Colisoes: +c[6], FatorCarga: +c[7]
      };
    });
  }

  function criarGraficoLinha(canvas, titulo, labelX, labelY, datasets){
    const ctx = canvas.getContext('2d');
    new Chart(ctx, {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: titulo, color: '#eaf0ff', font: {size: 16} },
          legend: { labels: {color: '#dbeafe'} },
          tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(3)} ms` } }
        },
        scales: {
          x: { title: {display: true, text: labelX, color: '#cfe3ff'}, ticks: {color: '#cfe3ff'} },
          y: { title: {display: true, text: labelY, color: '#cfe3ff'}, ticks: {color: '#cfe3ff'} }
        }
      }
    });
  }

  function criarGraficoBarras(canvas, titulo, labelX, labelY, labels, datasets){
    const ctx = canvas.getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: titulo, color: '#eaf0ff', font: {size: 16} },
          legend: { labels: {color: '#dbeafe'} },
          tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(3)} ms` } }
        },
        scales: {
          x: { title: {display: true, text: labelX, color: '#cfe3ff'}, ticks: {color: '#cfe3ff'} },
          y: { title: {display: true, text: labelY, color: '#cfe3ff'}, ticks: {color: '#cfe3ff'} }
        }
      }
    });
  }

  function criarGraficoDispersao(canvas, titulo, labelX, labelY, data){
    const ctx = canvas.getContext('2d');
    new Chart(ctx, {
      type: 'scatter',
      data: { datasets: [{ label: 'Tabelas Encadeadas', data, backgroundColor: '#f59e0b' }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: titulo, color: '#eaf0ff', font: {size: 16} },
          legend: { labels: {color: '#dbeafe'} },
          tooltip: { callbacks: { label: (ctx) => `Fator: ${ctx.parsed.x}, Colisões: ${ctx.parsed.y}` } }
        },
        scales: {
          x: { title: {display: true, text: labelX, color: '#cfe3ff'}, ticks: {color: '#cfe3ff'} },
          y: { title: {display: true, text: labelY, color: '#cfe3ff'}, ticks: {color: '#cfe3ff'} }
        }
      }
    });
  }

  (async ()=>{
    const dados = await carregarCSV();

    // Gráfico 1: Tempo de Inserção (Encadeada vs Aberta)
    const gruposQD = [...new Set(dados.map(d=>d.QuantidadeDados))].sort((a,b)=>a-b);
    const mediaPor = (tipo, campo) => gruposQD.map(q => {
      const subset = dados.filter(d => d.QuantidadeDados === q && d.TipoTabela === tipo);
      const soma = subset.reduce((s,x) => s + x[campo], 0);
      return subset.length ? soma / subset.length : 0;
    });

    criarGraficoLinha(
      document.getElementById('g_insercao'),
      'Comparação de Tempo de Inserção', 'Quantidade de Dados', 'Tempo de Inserção (ms)',
      [
        { label: 'Tabela Encadeada', data: gruposQD.map((x,i)=>({x,y: mediaPor('Encadeada','TempoInsercao')[i]})), borderColor:'#60a5fa', backgroundColor:'#60a5fa33', tension:.2 },
        { label: 'Tabela Aberta',    data: gruposQD.map((x,i)=>({x,y: mediaPor('Aberta','TempoInsercao')[i]})),    borderColor:'#34d399', backgroundColor:'#34d39933', tension:.2 }
      ]
    );

    // Gráfico 2: Tempo de Busca (Encadeada vs Aberta)
    criarGraficoLinha(
      document.getElementById('g_busca'),
      'Comparação de Tempo de Busca', 'Quantidade de Dados', 'Tempo de Busca (ms)',
      [
        { label: 'Tabela Encadeada', data: gruposQD.map((x,i)=>({x,y: mediaPor('Encadeada','TempoBusca')[i]})), borderColor:'#06b6d4', backgroundColor:'#06b6d433', tension:.2 },
        { label: 'Tabela Aberta',    data: gruposQD.map((x,i)=>({x,y: mediaPor('Aberta','TempoBusca')[i]})),    borderColor:'#a78bfa', backgroundColor:'#a78bfa33', tension:.2 }
      ]
    );

    // Gráfico 3: Funções Hash em Encadeada (10.000 elementos)
    const tamanhos = [29,97,251,499,911];
    const enc10k = dados.filter(d => d.TipoTabela==='Encadeada' && d.QuantidadeDados===10000);
    const divs = tamanhos.map(t => enc10k.find(d => d.TamanhoTabela===t && d.FuncaoHash==='Divisao')?.TempoInsercao ?? 0);
    const mult = tamanhos.map(t => enc10k.find(d => d.TamanhoTabela===t && d.FuncaoHash==='Multiplicacao')?.TempoInsercao ?? 0);
    criarGraficoBarras(
      document.getElementById('g_funcoes'),
      'Comparação de Funções Hash (Inserção - 10.000 elementos)', 'Tamanho da Tabela', 'Tempo de Inserção (ms)',
      tamanhos.map(String),
      [ { label:'Função Divisão', data:divs, backgroundColor:'#60a5fa' }, { label:'Função Multiplicação', data:mult, backgroundColor:'#34d399' } ]
    );

    // Gráfico 4: Fator de Carga × Colisões (Encadeada)
    const pontosEnc = dados.filter(d => d.TipoTabela==='Encadeada').map(d => ({x:+d.FatorCarga.toFixed(4), y:d.Colisoes}));
    criarGraficoDispersao(
      document.getElementById('g_carga_colisao'),
      'Relação Fator de Carga × Colisões (Encadeadas)', 'Fator de Carga', 'Número de Colisões', pontosEnc
    );

    // Gráfico 5: Sondagens/Clustering — Tabela Aberta (estimativa por fator de carga)
    const abertas = dados.filter(d => d.TipoTabela==='Aberta');
    const porCarga = [...new Map(abertas.map(d => [d.FatorCarga, d])).values()].sort((a,b)=>a.FatorCarga-b.FatorCarga);
    const estSondagem = porCarga.map(d => Math.max(1, +(1/(1-d.FatorCarga)).toFixed(3))); // heurística básica
    const labelsCarga = porCarga.map(d => +d.FatorCarga.toFixed(3));

    criarGraficoBarras(
      document.getElementById('g_aberta_cluster'),
      'Tabela Aberta: Heurística de Sondagens vs Fator de Carga', 'Fator de Carga', 'Sondagens Médias (estim.)',
      labelsCarga,
      [ { label:'Sondagens (estim.)', data: estSondagem, backgroundColor:'#f59e0b' } ]
    );
  })();
  </script>
</body>
</html>