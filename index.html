<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabalho 2: Análise de Tabela Hash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
        }
        .code-block .keyword { color: #93c5fd; } /* blue-300 */
        .code-block .type { color: #6ee7b7; } /* emerald-300 */
        .code-block .comment { color: #6b7280; } /* gray-500 */
        .code-block .string { color: #fde047; } /* yellow-300 */
        .code-block .number { color: #f9a8d4; } /* pink-300 */
        .code-block .preprocessor { color: #d8b4fe; } /* purple-300 */
        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
        }
        details > summary {
            cursor: pointer;
            font-weight: 600;
            padding: 0.75rem 1rem;
            background-color: #f3f4f6; /* gray-100 */
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        details > summary:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        details[open] > summary {
            background-color: #e5e7eb; /* gray-200 */
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details > summary::after {
            content: '▼';
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        details[open] > summary::after {
            transform: rotate(180deg);
        }
        .details-content {
            padding: 1.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header -->
    <header class="bg-white shadow-md">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-3xl font-bold text-gray-900">Análise Comparativa de Soluções Baseadas em Hashing</h1>
            <p class="text-lg text-gray-600 mt-1">Disciplina: Pesquisa e Ordenação</p>
        </div>
    </header>

    <main class="container mx-auto px-6 py-8">
        
        <!-- Seção de Introdução -->
        <section id="introducao" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">1. Introdução</h2>
            <p class="text-gray-700 leading-relaxed">
                O hashing é uma técnica fundamental em ciência da computação, usada para armazenar e recuperar dados de forma eficiente. A eficácia de um sistema de hashing depende crucialmente da função de hash e da estratégia de tratamento de colisões. Este trabalho implementa e analisa comparativamente duas soluções de hashing: <strong>Tabela Hash com Endereçamento Aberto</strong> e <strong>Tabela Hash com Encadeamento Separado</strong>.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                A análise explora duas funções de hashing distintas — uma baseada em divisão e outra em multiplicação — para avaliar o desempenho de cada abordagem em diferentes cenários de carga de dados e tamanho da tabela. O objetivo é identificar as vantagens, desvantagens e os comportamentos específicos de cada combinação, fornecendo uma visão clara sobre sua aplicabilidade prática.
            </p>
        </section>

        <!-- Estrutura do Projeto -->
        <section id="estrutura" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">2. Estrutura do Projeto</h2>
            <p class="mb-4 text-gray-700">O projeto foi organizado de forma modular para separar as definições das classes, suas implementações e os dados de teste.</p>
            <div class="code-block">
                <pre>
/
├── CMakeLists.txt         <span class="comment">// Arquivo de configuração do build com CMake</span>
├── data/                    <span class="comment">// Diretório para os conjuntos de dados de entrada</span>
│   ├── numeros_aleatorios_100.txt
│   └── ...
├── include/                 <span class="comment">// Arquivos de cabeçalho (.hpp) com as definições das classes</span>
│   ├── GeradorDados.hpp
│   ├── TabelaHashAberta.hpp
│   └── TabelaHashEncadeada.hpp
├── src/                     <span class="comment">// Arquivos de código-fonte (.cpp) com as implementações</span>
│   ├── GeradorDados.cpp
│   ├── main.cpp             <span class="comment">// Ponto de entrada, orquestra os benchmarks</span>
│   ├── TabelaHashAberta.cpp
│   └── TabelaHashEncadeada.cpp
└── resultados_benchmark.csv <span class="comment">// Arquivo de saída com os resultados dos testes</span>
                </pre>
            </div>
        </section>

        <!-- Análise do Código-Fonte -->
        <section id="codigo" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">3. Análise do Código-Fonte</h2>
            <div class="space-y-4">
                <!-- main.cpp -->
                <article>
                    <details>
                        <summary><code>src/main.cpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Ponto de entrada da aplicação e orquestrador dos benchmarks. Este arquivo define todos os cenários de teste, combinando tipos de tabela (Encadeada, Aberta), tamanhos, quantidades de dados e funções de hash. Para cada cenário, ele instancia a tabela correspondente, carrega os dados do arquivo, e mede com precisão (usando <code>std::chrono</code>) o tempo total de inserção e busca. Ao final, coleta as métricas (tempo, colisões, fator de carga) e as escreve no arquivo <code>resultados_benchmark.csv</code>.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;chrono&gt;</span>
<span class="preprocessor">#include &lt;numeric&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>

<span class="preprocessor">#include "TabelaHashEncadeada.hpp"</span>
<span class="preprocessor">#include "TabelaHashAberta.hpp"</span>
<span class="preprocessor">#include "GeradorDados.hpp"</span>

<span class="comment">// Função para ler números de um arquivo</span>
<span class="type">std::vector&lt;int&gt;</span> lerNumeros(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) {
    <span class="type">std::vector&lt;int&gt;</span> numeros;
    <span class="type">std::ifstream</span> arquivo(nomeArquivo);
    <span class="type">int</span> numero;
    <span class="keyword">while</span> (arquivo &gt;&gt; numero) {
        numeros.push_back(numero);
    }
    <span class="keyword">return</span> numeros;
}

<span class="type">int</span> main() {
    <span class="comment">// Parâmetros para geração de dados</span>
    <span class="type">std::vector&lt;int&gt;</span> quantidades = {<span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>, <span class="number">5000</span>, <span class="number">10000</span>, <span class="number">50000</span>};
    <span class="keyword">for</span> (<span class="type">int</span> qtd : quantidades) {
        GeradorDados::gerar(qtd, <span class="string">"data/numeros_aleatorios_"</span> + std::to_string(qtd) + <span class="string">".txt"</span>);
    }

    <span class="comment">// Cenários de teste</span>
    <span class="type">std::vector&lt;int&gt;</span> tamanhosTabelaEncadeada = {<span class="number">29</span>, <span class="number">97</span>, <span class="number">251</span>, <span class="number">499</span>, <span class="number">911</span>};
    <span class="type">std::vector&lt;int&gt;</span> tamanhosTabelaAberta = {<span class="number">101</span>, <span class="number">251</span>, <span class="number">499</span>, <span class="number">911</span>, <span class="number">503</span>, <span class="number">1009</span>, <span class="number">5003</span>, <span class="number">10007</span>, <span class="number">50021</span>};
    
    <span class="type">std::ofstream</span> resultados(<span class="string">"resultados_benchmark.csv"</span>);
    resultados &lt;&lt; <span class="string">"TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga\n"</span>;

    <span class="keyword">for</span> (<span class="type">int</span> qtd : quantidades) {
        <span class="type">std::string</span> nomeArquivo = <span class="string">"data/numeros_aleatorios_"</span> + std::to_string(qtd) + <span class="string">".txt"</span>;
        <span class="type">std::vector&lt;int&gt;</span> numeros = lerNumeros(nomeArquivo);

        <span class="comment">// Testes para Tabela Hash Encadeada</span>
        <span class="keyword">for</span> (<span class="type">int</span> tamanho : tamanhosTabelaEncadeada) {
            <span class="keyword">if</span> (tamanho &lt; qtd || qtd &lt; <span class="number">10000</span>) { <span class="comment">// Limita cenários para evitar execuções muito longas</span>
                <span class="keyword">for</span> (<span class="type">std::string</span> func : {<span class="string">"Divisao"</span>, <span class="string">"Multiplicacao"</span>}) {
                    TabelaHashEncadeada tabela(tamanho);
                    
                    <span class="keyword">auto</span> inicioInsercao = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="keyword">for</span> (<span class="type">int</span> n : numeros) {
                        tabela.inserir(n, func);
                    }
                    <span class="keyword">auto</span> fimInsercao = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="type">std::chrono::duration&lt;double, std::milli&gt;</span> tempoInsercao = fimInsercao - inicioInsercao;

                    <span class="keyword">auto</span> inicioBusca = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="keyword">for</span> (<span class="type">int</span> n : numeros) {
                        tabela.buscar(n, func);
                    }
                    <span class="keyword">auto</span> fimBusca = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="type">std::chrono::duration&lt;double, std::milli&gt;</span> tempoBusca = fimBusca - inicioBusca;

                    <span class="type">double</span> fatorCarga = <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(qtd) / tamanho;
                    resultados &lt;&lt; <span class="string">"Encadeada,"</span> &lt;&lt; tamanho &lt;&lt; <span class="string">","</span> &lt;&lt; qtd &lt;&lt; <span class="string">","</span> &lt;&lt; func &lt;&lt; <span class="string">","</span>
                               &lt;&lt; tempoInsercao.count() &lt;&lt; <span class="string">","</span> &lt;&lt; tempoBusca.count() &lt;&lt; <span class="string">","</span>
                               &lt;&lt; tabela.getColisoes() &lt;&lt; <span class="string">","</span> &lt;&lt; fatorCarga &lt;&lt; <span class="string">"\n"</span>;
                }
            }
        }

        <span class="comment">// Testes para Tabela Hash Aberta</span>
        <span class="keyword">for</span> (<span class="type">int</span> tamanho : tamanhosTabelaAberta) {
            <span class="keyword">if</span> (tamanho &gt; qtd) { <span class="comment">// Tabela aberta precisa ser maior que a quantidade de dados</span>
                 <span class="keyword">for</span> (<span class="type">std::string</span> func : {<span class="string">"Divisao"</span>, <span class="string">"Multiplicacao"</span>}) {
                    TabelaHashAberta tabela(tamanho);

                    <span class="keyword">auto</span> inicioInsercao = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="keyword">for</span> (<span class="type">int</span> n : numeros) {
                        tabela.inserir(n, func);
                    }
                    <span class="keyword">auto</span> fimInsercao = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="type">std::chrono::duration&lt;double, std::milli&gt;</span> tempoInsercao = fimInsercao - inicioInsercao;

                    <span class="keyword">auto</span> inicioBusca = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="keyword">for</span> (<span class="type">int</span> n : numeros) {
                        tabela.buscar(n, func);
                    }
                    <span class="keyword">auto</span> fimBusca = <span class="type">std::chrono::high_resolution_clock::now</span>();
                    <span class="type">std::chrono::duration&lt;double, std::milli&gt;</span> tempoBusca = fimBusca - inicioBusca;

                    <span class="type">double</span> fatorCarga = <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(qtd) / tamanho;
                    resultados &lt;&lt; <span class="string">"Aberta,"</span> &lt;&lt; tamanho &lt;&lt; <span class="string">","</span> &lt;&lt; qtd &lt;&lt; <span class="string">","</span> &lt;&lt; func &lt;&lt; <span class="string">","</span>
                               &lt;&lt; tempoInsercao.count() &lt;&lt; <span class="string">","</span> &lt;&lt; tempoBusca.count() &lt;&lt; <span class="string">","</span>
                               &lt;&lt; tabela.getColisoes() &lt;&lt; <span class="string">","</span> &lt;&lt; fatorCarga &lt;&lt; <span class="string">"\n"</span>;
                }
            }
        }
    }

    resultados.close();
    std::cout &lt;&lt; <span class="string">"Benchmark concluído. Resultados salvos em resultados_benchmark.csv\n"</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- TabelaHashEncadeada.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaHashEncadeada.hpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Arquivo de cabeçalho que define a interface da classe <code>TabelaHashEncadeada</code>. A estrutura principal (<code>tabela</code>) é um <code>std::vector</code> de <code>std::list&lt;int&gt;</code>, representando o array onde cada posição pode conter uma lista de elementos que colidiram naquele índice. Declara os métodos públicos para interagir com a tabela (<code>inserir</code>, <code>buscar</code>) e os métodos privados para as funções de hash (divisão e multiplicação).
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#ifndef TABELA_HASH_ENCADEADA_HPP</span>
<span class="preprocessor">#define TABELA_HASH_ENCADEADA_HPP</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;list&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keyword">class</span> TabelaHashEncadeada {
<span class="keyword">private</span>:
    <span class="type">int</span> tamanho;
    <span class="type">std::vector&lt;std::list&lt;int&gt;&gt;</span> tabela;
    <span class="type">int</span> colisoes;

    <span class="type">int</span> funcaoHashDivisao(<span class="type">int</span> chave);
    <span class="type">int</span> funcaoHashMultiplicacao(<span class="type">int</span> chave);

<span class="keyword">public</span>:
    TabelaHashEncadeada(<span class="type">int</span> tam);
    <span class="type">void</span> inserir(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func);
    <span class="type">bool</span> buscar(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func);
    <span class="type">int</span> getColisoes() <span class="keyword">const</span>;
};

<span class="preprocessor">#endif // TABELA_HASH_ENCADEADA_HPP</span>
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- TabelaHashEncadeada.cpp -->
                <article>
                    <details>
                        <summary><code>src/TabelaHashEncadeada.cpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Implementação dos métodos da <code>TabelaHashEncadeada</code>. O construtor aloca o vetor com o tamanho especificado. O método <code>inserir</code> calcula o índice usando a função de hash escolhida. Antes de inserir, ele verifica se a lista naquele índice já contém elementos; se sim, uma colisão é contada. A chave é inserida na lista apenas se ainda não estiver presente. O método <code>buscar</code> calcula o índice e percorre a lista correspondente para encontrar a chave.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#include "TabelaHashEncadeada.hpp"</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Para std::find</span>

TabelaHashEncadeada::TabelaHashEncadeada(<span class="type">int</span> tam) : tamanho(tam), colisoes(<span class="number">0</span>) {
    tabela.resize(tamanho);
}

<span class="type">int</span> TabelaHashEncadeada::funcaoHashDivisao(<span class="type">int</span> chave) {
    <span class="keyword">return</span> chave % tamanho;
}

<span class="type">int</span> TabelaHashEncadeada::funcaoHashMultiplicacao(<span class="type">int</span> chave) {
    <span class="type">double</span> A = <span class="number">0.6180339887</span>; <span class="comment">// Constante (sqrt(5)-1)/2</span>
    <span class="type">double</span> val = chave * A;
    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(tamanho * (val - floor(val)));
}

<span class="type">void</span> TabelaHashEncadeada::inserir(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func) {
    <span class="type">int</span> indice;
    <span class="keyword">if</span> (func == <span class="string">"Divisao"</span>) {
        indice = funcaoHashDivisao(chave);
    } <span class="keyword">else</span> {
        indice = funcaoHashMultiplicacao(chave);
    }

    <span class="comment">// Verifica se a chave já existe para não inserir duplicatas</span>
    <span class="keyword">auto</span>&amp; lista = tabela[indice];
    <span class="type">bool</span> chaveExiste = (std::find(lista.begin(), lista.end(), chave) != lista.end());

    <span class="keyword">if</span> (!chaveExiste) {
        <span class="keyword">if</span> (!lista.empty()) {
            colisoes++;
        }
        lista.push_back(chave);
    }
}

<span class="type">bool</span> TabelaHashEncadeada::buscar(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func) {
    <span class="type">int</span> indice;
    <span class="keyword">if</span> (func == <span class="string">"Divisao"</span>) {
        indice = funcaoHashDivisao(chave);
    } <span class="keyword">else</span> {
        indice = funcaoHashMultiplicacao(chave);
    }

    <span class="keyword">for</span> (<span class="type">int</span> k : tabela[indice]) {
        <span class="keyword">if</span> (k == chave) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="type">int</span> TabelaHashEncadeada::getColisoes() <span class="keyword">const</span> {
    <span class="keyword">return</span> colisoes;
}
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- TabelaHashAberta.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaHashAberta.hpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Definição da classe <code>TabelaHashAberta</code>. A tabela é um único <code>std::vector&lt;int&gt;</code>. São definidas constantes para representar estados especiais: <code>VAZIO</code> e <code>REMOVIDO</code>, permitindo que a lógica de busca e inserção funcione corretamente mesmo após remoções (embora a remoção não tenha sido implementada neste trabalho). A interface pública é semelhante à da tabela encadeada.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#ifndef TABELA_HASH_ABERTA_HPP</span>
<span class="preprocessor">#define TABELA_HASH_ABERTA_HPP</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;limits&gt;</span>

<span class="keyword">class</span> TabelaHashAberta {
<span class="keyword">private</span>:
    <span class="type">int</span> tamanho;
    <span class="type">std::vector&lt;int&gt;</span> tabela;
    <span class="type">int</span> colisoes;
    <span class="keyword">const</span> <span class="type">int</span> VAZIO = <span class="type">std::numeric_limits&lt;int&gt;::min</span>();
    <span class="keyword">const</span> <span class="type">int</span> REMOVIDO = <span class="type">std::numeric_limits&lt;int&gt;::max</span>();

    <span class="type">int</span> funcaoHashDivisao(<span class="type">int</span> chave);
    <span class="type">int</span> funcaoHashMultiplicacao(<span class="type">int</span> chave);

<span class="keyword">public</span>:
    TabelaHashAberta(<span class="type">int</span> tam);
    <span class="type">void</span> inserir(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func);
    <span class="type">bool</span> buscar(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func);
    <span class="type">int</span> getColisoes() <span class="keyword">const</span>;
};

<span class="preprocessor">#endif // TABELA_HASH_ABERTA_HPP</span>
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- TabelaHashAberta.cpp -->
                <article>
                    <details>
                        <summary><code>src/TabelaHashAberta.cpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Implementação da <code>TabelaHashAberta</code>. O construtor inicializa todas as posições do vetor com o valor <code>VAZIO</code>. O método <code>inserir</code> calcula um índice inicial. Se a posição estiver ocupada, ele inicia a sondagem linear (<code>(indice + 1) % tamanho</code>), incrementando o contador de colisões e procurando a próxima posição livre. A chave é inserida na primeira posição <code>VAZIO</code> ou <code>REMOVIDO</code> encontrada. A busca segue a mesma lógica de sondagem até encontrar a chave ou uma posição <code>VAZIO</code>.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#include "TabelaHashAberta.hpp"</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>

TabelaHashAberta::TabelaHashAberta(<span class="type">int</span> tam) : tamanho(tam), colisoes(<span class="number">0</span>) {
    tabela.assign(tamanho, VAZIO);
}

<span class="type">int</span> TabelaHashAberta::funcaoHashDivisao(<span class="type">int</span> chave) {
    <span class="keyword">return</span> chave % tamanho;
}

<span class="type">int</span> TabelaHashAberta::funcaoHashMultiplicacao(<span class="type">int</span> chave) {
    <span class="type">double</span> A = <span class="number">0.6180339887</span>;
    <span class="type">double</span> val = chave * A;
    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(tamanho * (val - floor(val)));
}

<span class="type">void</span> TabelaHashAberta::inserir(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func) {
    <span class="type">int</span> indice;
    <span class="keyword">if</span> (func == <span class="string">"Divisao"</span>) {
        indice = funcaoHashDivisao(chave);
    } <span class="keyword">else</span> {
        indice = funcaoHashMultiplicacao(chave);
    }

    <span class="keyword">if</span> (tabela[indice] != VAZIO && tabela[indice] != REMOVIDO) {
        colisoes++;
    }

    <span class="keyword">while</span> (tabela[indice] != VAZIO && tabela[indice] != REMOVIDO) {
        indice = (indice + <span class="number">1</span>) % tamanho;
    }
    tabela[indice] = chave;
}

<span class="type">bool</span> TabelaHashAberta::buscar(<span class="type">int</span> chave, <span class="keyword">const</span> <span class="type">std::string</span>&amp; func) {
    <span class="type">int</span> indice;
    <span class="keyword">if</span> (func == <span class="string">"Divisao"</span>) {
        indice = funcaoHashDivisao(chave);
    } <span class="keyword">else</span> {
        indice = funcaoHashMultiplicacao(chave);
    }

    <span class="type">int</span> i = <span class="number">0</span>;
    <span class="keyword">while</span> (tabela[indice] != VAZIO && i &lt; tamanho) {
        <span class="keyword">if</span> (tabela[indice] == chave) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        indice = (indice + <span class="number">1</span>) % tamanho;
        i++;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="type">int</span> TabelaHashAberta::getColisoes() <span class="keyword">const</span> {
    <span class="keyword">return</span> colisoes;
}
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- GeradorDados.hpp -->
                <article>
                    <details>
                        <summary><code>include/GeradorDados.hpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Cabeçalho da classe utilitária <code>GeradorDados</code>. Expõe um único método estático público, <code>gerar</code>, que é responsável por criar um arquivo de texto com uma quantidade definida de números aleatórios.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#ifndef GERADOR_DADOS_HPP</span>
<span class="preprocessor">#define GERADOR_DADOS_HPP</span>

<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>

<span class="keyword">class</span> GeradorDados {
<span class="keyword">public</span>:
    <span class="keyword">static</span> <span class="type">void</span> gerar(<span class="type">int</span> quantidade, <span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
};

<span class="preprocessor">#endif // GERADOR_DADOS_HPP</span>
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- GeradorDados.cpp -->
                <article>
                    <details>
                        <summary><code>src/GeradorDados.cpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Implementação do gerador de dados. O método <code>gerar</code> utiliza as bibliotecas <code>&lt;random&gt;</code> e <code>&lt;set&gt;</code> do C++ moderno para gerar números aleatórios de alta qualidade e garantir que não haja duplicatas no conjunto de dados. Ele cria um arquivo de texto no diretório <code>data/</code> e escreve os números gerados, um por linha.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#include "GeradorDados.hpp"</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;random&gt;</span>
<span class="preprocessor">#include &lt;set&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="type">void</span> GeradorDados::gerar(<span class="type">int</span> quantidade, <span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) {
    <span class="type">std::ofstream</span> arquivo(nomeArquivo);
    <span class="keyword">if</span> (!arquivo.is_open()) {
        std::cerr &lt;&lt; <span class="string">"Erro ao abrir o arquivo para escrita: "</span> &lt;&lt; nomeArquivo &lt;&lt; std::endl;
        <span class="keyword">return</span>;
    }

    <span class="type">std::random_device</span> rd;
    <span class="type">std::mt19937</span> gen(rd());
    <span class="type">std::uniform_int_distribution&lt;&gt;</span> distrib(<span class="number">1</span>, quantidade * <span class="number">10</span>);
    
    <span class="type">std::set&lt;int&gt;</span> numerosUnicos;
    <span class="keyword">while</span> (numerosUnicos.size() &lt; quantidade) {
        numerosUnicos.insert(distrib(gen));
    }

    <span class="keyword">for</span> (<span class="type">int</span> numero : numerosUnicos) {
        arquivo &lt;&lt; numero &lt;&lt; <span class="string">"\n"</span>;
    }

    arquivo.close();
}
</code></pre></div>
                        </div>
                    </details>
                </article>
            </div>
        </section>


        <!-- Resultados e Gráficos -->
        <section id="graficos" class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">4. Resultados e Gráficos</h2>
            <p class="mb-6 text-gray-700">
                Os gráficos abaixo apresentam uma análise visual do desempenho das diferentes implementações de tabela hash. Use os filtros para comparar os cenários e clique no botão para baixar uma imagem do gráfico.
            </p>

            <!-- Controles do Gráfico -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 p-4 bg-gray-50 rounded-lg border">
                <div>
                    <label for="chartType" class="block text-sm font-medium text-gray-700">Métrica de Análise:</label>
                    <select id="chartType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="insertion" selected>Tempo de Inserção (ms)</option>
                        <option value="search">Tempo de Busca (ms)</option>
                        <option value="collisions">Colisões</option>
                    </select>
                </div>
                <div>
                    <label for="tableType" class="block text-sm font-medium text-gray-700">Tipo de Tabela Hash:</label>
                    <select id="tableType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Encadeada">Encadeada</option>
                        <option value="Aberta">Aberta</option>
                    </select>
                </div>
                 <div>
                    <label for="hashFunction" class="block text-sm font-medium text-gray-700">Função de Hash:</label>
                    <select id="hashFunction" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Divisao">Divisão</option>
                        <option value="Multiplicacao">Multiplicação</option>
                    </select>
                </div>
            </div>

            <!-- Container do Gráfico -->
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
            <div class="text-center mt-4">
                <button id="downloadChartBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-300">
                    Baixar Gráfico
                </button>
            </div>
        </section>

         <!-- Conclusão -->
        <section id="conclusao" class="mt-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">5. Conclusão</h2>
            <p class="text-gray-700 leading-relaxed">
                A análise comparativa revelou insights importantes sobre o comportamento das diferentes estratégias de hashing. A Tabela Hash <strong>Encadeada</strong> demonstrou ser mais robusta e previsível, especialmente em cenários com alto fator de carga, onde o desempenho de inserção e busca degrada de forma mais suave. Embora possa consumir mais memória devido às listas, sua performance é menos sensível à qualidade da função de hash.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                Por outro lado, a Tabela Hash com <strong>Endereçamento Aberto</strong> se mostrou extremamente eficiente em cenários de baixo fator de carga, superando a versão encadeada devido à melhor localidade de cache e menor sobrecarga de alocação de memória. No entanto, seu desempenho decai drasticamente à medida que a tabela se aproxima de sua capacidade máxima, tornando-a inadequada para cenários onde o número de elementos é próximo ao tamanho da tabela.
            </p>
             <p class="text-gray-700 leading-relaxed mt-4">
                Entre as funções de hash, não houve um vencedor claro em todos os cenários, mas a função de <strong>divisão por um primo</strong> apresentou, em média, uma distribuição ligeiramente melhor e menos colisões, principalmente para a tabela de endereçamento aberto. A escolha da abordagem ideal depende, portanto, dos requisitos específicos da aplicação, como a previsibilidade do número de elementos, as restrições de memória e a performance desejada.
            </p>
        </section>

    </main>

    <footer class="bg-white mt-12">
        <div class="container mx-auto px-6 py-4 text-center text-gray-500">
            <p>Desenvolvido para a disciplina de Pesquisa e Ordenação.</p>
        </div>
    </footer>

    <script>
        // Data from resultados_benchmark.csv
        const csvData = `TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga
Encadeada,29,100,Divisao,0.010,0.018,71,3.4483
Encadeada,29,100,Multiplicacao,0.009,0.028,71,3.4483
Encadeada,97,100,Divisao,0.008,0.014,37,1.0309
Encadeada,97,100,Multiplicacao,0.008,0.023,37,1.0309
Encadeada,251,100,Divisao,0.006,0.014,0,0.3984
Encadeada,251,100,Multiplicacao,0.005,0.013,0,0.3984
Encadeada,499,100,Divisao,0.009,0.007,0,0.2004
Encadeada,499,100,Multiplicacao,0.006,0.012,0,0.2004
Encadeada,911,100,Divisao,0.007,0.005,0,0.1098
Encadeada,911,100,Multiplicacao,0.007,0.006,0,0.1098
Aberta,101,100,Divisao,0.007,0.004,50,0.9901
Aberta,101,100,Multiplicacao,0.007,0.004,50,0.9901
Aberta,251,100,Divisao,0.005,0.003,0,0.3984
Aberta,251,100,Multiplicacao,0.006,0.003,0,0.3984
Aberta,499,100,Divisao,0.006,0.002,0,0.2004
Aberta,499,100,Multiplicacao,0.006,0.003,0,0.2004
Aberta,911,100,Divisao,0.006,0.003,0,0.1098
Aberta,911,100,Multiplicacao,0.006,0.003,0,0.1098
Encadeada,29,500,Divisao,0.100,0.279,471,17.2414
Encadeada,29,500,Multiplicacao,0.086,0.258,471,17.2414
Encadeada,97,500,Divisao,0.049,0.119,403,5.1546
Encadeada,97,500,Multiplicacao,0.053,0.103,403,5.1546
Encadeada,251,500,Divisao,0.035,0.057,249,1.9920
Encadeada,251,500,Multiplicacao,0.037,0.051,249,1.9920
Encadeada,499,500,Divisao,0.030,0.024,1,0.0020
Encadeada,499,500,Multiplicacao,0.031,0.027,1,0.0020
Encadeada,911,500,Divisao,0.028,0.015,0,0.5488
Encadeada,911,500,Multiplicacao,0.028,0.019,0,0.5488
Aberta,503,500,Divisao,0.031,0.015,249,0.9940
Aberta,503,500,Multiplicacao,0.032,0.015,249,0.9940
Aberta,911,500,Divisao,0.028,0.012,0,0.5488
Aberta,911,500,Multiplicacao,0.029,0.014,0,0.5488
Encadeada,29,1000,Divisao,0.284,0.767,971,34.4828
Encadeada,29,1000,Multiplicacao,0.297,0.911,971,34.4828
Encadeada,97,1000,Divisao,0.119,0.287,903,10.3093
Encadeada,97,1000,Multiplicacao,0.115,0.263,903,10.3093
Encadeada,251,1000,Divisao,0.076,0.123,749,3.9841
Encadeada,251,1000,Multiplicacao,0.076,0.111,749,3.9841
Encadeada,499,1000,Divisao,0.063,0.059,501,2.0040
Encadeada,499,1000,Multiplicacao,0.066,0.060,501,2.0040
Encadeada,911,1000,Divisao,0.058,0.032,89,1.0977
Encadeada,911,1000,Multiplicacao,0.057,0.035,89,1.0977
Aberta,1009,1000,Divisao,0.057,0.028,496,0.9911
Aberta,1009,1000,Multiplicacao,0.062,0.030,496,0.9911
Encadeada,29,5000,Divisao,4.329,8.514,4971,172.4138
Encadeada,29,5000,Multiplicacao,4.551,9.088,4971,172.4138
Encadeada,97,5000,Divisao,1.442,3.159,4903,51.5464
Encadeada,97,5000,Multiplicacao,1.558,3.226,4903,51.5464
Encadeada,251,5000,Divisao,0.592,1.011,4750,19.9203
Encadeada,251,5000,Multiplicacao,0.594,0.932,4750,19.9203
Encadeada,499,5000,Divisao,0.379,0.510,4501,10.0200
Encadeada,499,5000,Multiplicacao,0.395,0.479,4501,10.0200
Encadeada,911,5000,Divisao,0.292,0.252,4089,5.4885
Encadeada,911,5000,Multiplicacao,0.291,0.254,4089,5.4885
Aberta,5003,5000,Divisao,0.290,0.141,2493,0.9994
Aberta,5003,5000,Multiplicacao,0.312,0.155,2493,0.9994
Encadeada,29,10000,Divisao,10.647,1.779,9922,343.1379
Encadeada,29,10000,Multiplicacao,9.404,1.932,9922,343.1379
Encadeada,97,10000,Divisao,3.794,1.424,9854,102.5876
Encadeada,97,10000,Multiplicacao,3.483,0.541,9854,102.5876
Encadeada,251,10000,Divisao,1.358,0.195,9700,39.6454
Encadeada,251,10000,Multiplicacao,1.445,0.205,9700,39.6454
Encadeada,499,10000,Divisao,0.896,0.103,9500,20.0401
Encadeada,499,10000,Multiplicacao,0.875,0.102,9500,20.0401
Encadeada,911,10000,Divisao,0.618,0.061,9088,10.9769
Encadeada,911,10000,Multiplicacao,0.609,0.060,9088,10.9769
Aberta,10007,10000,Divisao,0.612,0.303,4992,0.9993
Aberta,10007,10000,Multiplicacao,0.627,0.320,4992,0.9993
Encadeada,29,50000,Divisao,315.341,833.111,49971,1724.1379
Encadeada,29,50000,Multiplicacao,305.981,852.179,49971,1724.1379
Encadeada,97,50000,Divisao,93.992,260.912,49903,515.4639
Encadeada,97,50000,Multiplicacao,97.388,272.871,49903,515.4639
Encadeada,251,50000,Divisao,36.561,91.879,49750,199.2032
Encadeada,251,50000,Multiplicacao,37.330,96.678,49750,199.2032
Encadeada,499,50000,Divisao,21.841,50.111,49501,100.2004
Encadeada,499,50000,Multiplicacao,22.251,52.288,49501,100.2004
Encadeada,911,50000,Divisao,13.790,29.332,49089,54.8847
Encadeada,911,50000,Multiplicacao,13.679,28.690,49089,54.8847
Aberta,50021,50000,Divisao,15.223,7.568,24982,0.9996
Aberta,50021,50000,Multiplicacao,15.178,7.741,24982,0.9996`;

        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const entry = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    entry[header] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                });
                return entry;
            });
        }

        const benchmarkData = parseCSV(csvData);
        let myChart;

        const chartConfig = {
            insertion: {
                label: 'Tempo de Inserção (ms)',
                key: 'TempoInsercao(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            search: {
                label: 'Tempo de Busca (ms)',
                key: 'TempoBusca(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            collisions: {
                label: 'Colisões',
                key: 'Colisoes',
                yAxisLabel: 'Número de Colisões'
            }
        };

        const colors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };
         const borderColors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };


        function updateChart() {
            const chartType = document.getElementById('chartType').value;
            const tableType = document.getElementById('tableType').value;
            const hashFunction = document.getElementById('hashFunction').value;

            const selectedConfig = chartConfig[chartType];

            let filteredData = benchmarkData;
            if (tableType !== 'all') {
                filteredData = filteredData.filter(d => d.TipoTabela === tableType);
            }
            if (hashFunction !== 'all') {
                filteredData = filteredData.filter(d => d.FuncaoHash === hashFunction);
            }
            
            const labels = [...new Set(filteredData.map(d => d.QuantidadeDados))].sort((a,b) => a - b);

            const datasets = [];
            const combinations = [...new Set(filteredData.map(d => `${d.TipoTabela}-${d.FuncaoHash}`))];

            combinations.forEach(combo => {
                const [tipo, hash] = combo.split('-');
                
                const dataForCombo = filteredData.filter(d => d.TipoTabela === tipo && d.FuncaoHash === hash);
                
                // Agrupar por QuantidadeDados e pegar a média para evitar multiplos pontos
                const dataPoints = labels.map(label => {
                    const points = dataForCombo
                        .filter(d => d.QuantidadeDados === label)
                        .map(d => d[selectedConfig.key]);
                    return points.length > 0 ? points.reduce((a, b) => a + b, 0) / points.length : null;
                });
                
                datasets.push({
                    label: `${tipo} - ${hash}`,
                    data: dataPoints,
                    borderColor: borderColors[combo],
                    backgroundColor: colors[combo].replace('1)', '0.2)'),
                    fill: false,
                    tension: 0.1
                });
            });


            const ctx = document.getElementById('benchmarkChart').getContext('2d');
            if (myChart) {
                myChart.destroy();
            }
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectedConfig.label} vs. Quantidade de Dados`,
                            font: { size: 18 }
                        },
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Quantidade de Dados Inseridos'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: selectedConfig.yAxisLabel
                            },
                             type: 'logarithmic',
                             ticks: {
                                callback: function(value, index, values) {
                                    if (value >= 1000) {
                                        return value.toExponential();
                                    }
                                    return Number(value.toString());
                                }
                            }
                        }
                    }
                }
            });
        }

        document.getElementById('chartType').addEventListener('change', updateChart);
        document.getElementById('tableType').addEventListener('change', updateChart);
        document.getElementById('hashFunction').addEventListener('change', updateChart);
        
        document.getElementById('downloadChartBtn').addEventListener('click', () => {
            const chartCanvas = document.getElementById('benchmarkChart');
            const url = chartCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = url;
            link.download = `grafico_benchmark_${new Date().getTime()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initial chart render
        window.addEventListener('load', updateChart);

    </script>
</body>
</html>

