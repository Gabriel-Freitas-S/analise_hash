<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabalho 2: Análise de Tabela Hash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
        }
        .code-block .keyword { color: #93c5fd; } /* blue-300 */
        .code-block .type { color: #6ee7b7; } /* emerald-300 */
        .code-block .comment { color: #6b7280; } /* gray-500 */
        .code-block .string { color: #fde047; } /* yellow-300 */
        .code-block .number { color: #f9a8d4; } /* pink-300 */
        .code-block .preprocessor { color: #d8b4fe; } /* purple-300 */
        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
        }
        details > summary {
            cursor: pointer;
            font-weight: 600;
            padding: 0.75rem 1rem;
            background-color: #f3f4f6; /* gray-100 */
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        details > summary:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        details[open] > summary {
            background-color: #e5e7eb; /* gray-200 */
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details > summary::after {
            content: '▼';
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        details[open] > summary::after {
            transform: rotate(180deg);
        }
        .details-content {
            padding: 1.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header -->
    <header class="bg-white shadow-md">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-3xl font-bold text-gray-900">Análise Comparativa de Soluções Baseadas em Hashing</h1>
            <p class="text-lg text-gray-600 mt-1">Disciplina: Pesquisa e Ordenação</p>
        </div>
    </header>

    <main class="container mx-auto px-6 py-8">
        
        <!-- Seção de Introdução -->
        <section id="introducao" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">1. Introdução</h2>
            <p class="text-gray-700 leading-relaxed">
                O hashing é uma técnica fundamental em ciência da computação, usada para armazenar e recuperar dados de forma eficiente. A eficácia de um sistema de hashing depende crucialmente da função de hash e da estratégia de tratamento de colisões. Este trabalho implementa e analisa comparativamente duas soluções de hashing: <strong>Tabela Hash com Endereçamento Aberto</strong> e <strong>Tabela Hash com Encadeamento Separado</strong>.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                A análise explora duas funções de hashing distintas — uma baseada em divisão e outra em multiplicação — para avaliar o desempenho de cada abordagem em diferentes cenários de carga de dados e tamanho da tabela. O objetivo é identificar as vantagens, desvantagens e os comportamentos específicos de cada combinação, fornecendo uma visão clara sobre sua aplicabilidade prática.
            </p>
        </section>

        <!-- Estrutura do Projeto -->
        <section id="estrutura" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">2. Estrutura do Projeto</h2>
            <p class="mb-4 text-gray-700">O projeto foi organizado de forma modular para separar as definições das classes, suas implementações e os dados de teste. A estrutura atual reflete nomes mais claros e apropriados para cada componente.</p>
            <div class="code-block">
                <pre>
/
├── CMakeLists.txt              <span class="comment">// Arquivo de configuração do build com CMake</span>
├── data/                        <span class="comment">// Diretório para os conjuntos de dados de entrada</span>
│   ├── numeros_aleatorios_100.txt
│   ├── numeros_aleatorios_500.txt
│   ├── numeros_aleatorios_1000.txt
│   ├── numeros_aleatorios_5000.txt
│   ├── numeros_aleatorios_10000.txt
│   └── numeros_aleatorios_50000.txt
├── include/                     <span class="comment">// Arquivos de cabeçalho (.hpp) com as definições das classes</span>
│   ├── CarregadorDados.hpp       <span class="comment">// Carregamento de datasets da pasta data/</span>
│   ├── TabelaEncadeada.hpp       <span class="comment">// Tabela hash com encadeamento</span>
│   └── TabelaAberta.hpp          <span class="comment">// Tabela hash com endereçamento aberto</span>
├── src/                         <span class="comment">// Arquivos de código-fonte (.cpp) com as implementações</span>
│   ├── main.cpp                  <span class="comment">// Ponto de entrada, orquestra os benchmarks</span>
│   ├── CarregadorDados.cpp       <span class="comment">// Implementação do carregador</span>
│   ├── TabelaEncadeada.cpp       <span class="comment">// Implementação do encadeamento</span>
│   └── TabelaAberta.cpp          <span class="comment">// Implementação do endereçamento aberto</span>
├── index.html                   <span class="comment">// Página web com análise completa</span>
└── resultados_benchmark.csv     <span class="comment">// Arquivo de saída com os resultados dos testes</span>
                </pre>
            </div>
        </section>

        <!-- Análise do Código-Fonte -->
        <section id="codigo" class="mb-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">3. Análise do Código-Fonte</h2>
            <div class="space-y-4">
                <!-- main.cpp -->
                <article>
                    <details>
                        <summary><code>src/main.cpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Ponto de entrada da aplicação e orquestrador dos benchmarks. Este arquivo define todos os cenários de teste, combinando tipos de tabela (Encadeada, Aberta), tamanhos, quantidades de dados e funções de hash. Para cada cenário, ele instancia a tabela correspondente, carrega os dados usando o <code>CarregadorDados</code>, e mede com precisão (usando <code>std::chrono</code>) o tempo total de inserção e busca. Ao final, coleta as métricas (tempo, colisões, fator de carga) e as escreve no arquivo <code>resultados_benchmark.csv</code>.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;chrono&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;memory&gt;</span>

<span class="preprocessor">#include "TabelaEncadeada.hpp"</span>
<span class="preprocessor">#include "TabelaAberta.hpp"</span>
<span class="preprocessor">#include "CarregadorDados.hpp"</span>

<span class="keyword">struct</span> ResultadoTeste {
    <span class="type">std::string</span> tipoTabela;
    <span class="type">size_t</span> tamanhoTabela;
    <span class="type">size_t</span> quantidadeDados;
    <span class="type">std::string</span> tipoFuncaoHash;
    <span class="type">double</span> tempoInsercao;
    <span class="type">double</span> tempoBusca;
    <span class="type">size_t</span> colisoes;
    <span class="type">double</span> fatorCarga;
};

<span class="keyword">class</span> BenchmarkManager {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;ResultadoTeste&gt;</span> resultados;

    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;
    <span class="type">double</span> medirTempo(Func&amp;&amp; func) {
        <span class="keyword">auto</span> inicio = <span class="type">std::chrono::high_resolution_clock::now</span>();
        func();
        <span class="keyword">auto</span> fim = <span class="type">std::chrono::high_resolution_clock::now</span>();
        <span class="keyword">auto</span> duracao = <span class="type">std::chrono::duration_cast&lt;std::chrono::microseconds&gt;</span>(fim - inicio);
        <span class="keyword">return</span> duracao.count() / <span class="number">1000.0</span>;
    }

<span class="keyword">public</span>:
    <span class="type">void</span> testarTabelaEncadeada(<span class="keyword">const</span> <span class="type">std::vector&lt;int&gt;</span>&amp; dados,
                              <span class="keyword">const</span> <span class="type">std::vector&lt;int&gt;</span>&amp; dadosBusca,
                              <span class="type">size_t</span> tamanhoTabela) {
        TabelaEncadeada tabela(tamanhoTabela);
        <span class="type">double</span> tempoInsercao = medirTempo([&amp;]() { 
            <span class="keyword">for</span> (<span class="type">int</span> v : dados) 
                tabela.inserir(v, TabelaEncadeada::TipoHash::DIVISAO); 
        });
        <span type="comment">// ... resto da implementação</span>
    }

    <span type="comment">// Métodos similares para tabela aberta e relatórios</span>
};

<span class="type">int</span> main() {
    CarregadorDados carregador;
    BenchmarkManager benchmark;
    
    <span class="comment">// Execução dos benchmarks para todos os cenários</span>
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="type">std::string</span>&amp; arquivo : ARQS) {
        <span class="keyword">auto</span> dados = carregador.carregarDeArquivo(arquivo);
        <span class="comment">// Testes para diferentes configurações</span>
    }
    
    benchmark.imprimirRelatorio();
    benchmark.salvarResultados(<span class="string">"resultados_benchmark.csv"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- TabelaEncadeada.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaEncadeada.hpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Arquivo de cabeçalho que define a interface da classe <code>TabelaEncadeada</code>. A estrutura principal utiliza um <code>std::vector</code> de ponteiros inteligentes para nós de listas encadeadas, representando o array onde cada posição pode conter uma lista de elementos que colidiram naquele índice. Declara os métodos públicos para interagir com a tabela e os métodos privados para as funções de hash (divisão e multiplicação).
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#pragma once</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;memory&gt;</span>
<span class="preprocessor">#include &lt;stdexcept&gt;</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>

<span class="keyword">struct</span> No {
    <span class="type">int</span> valor;
    <span class="type">std::unique_ptr&lt;No&gt;</span> proximo;
    
    <span class="keyword">explicit</span> No(<span class="type">int</span> val) : valor(val), proximo(<span class="keyword">nullptr</span>) {}
};

<span class="keyword">class</span> TabelaEncadeada {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;std::unique_ptr&lt;No&gt;&gt;</span> tabela;
    <span class="type">size_t</span> tamanho;
    <span class="type">size_t</span> numElementos;
    
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> CONSTANTE_MULTIPLICACAO = <span class="number">0.6180339887</span>;
    
<span class="keyword">public</span>:
    <span class="keyword">enum</span> <span class="keyword">class</span> TipoHash { 
        DIVISAO,
        MULTIPLICACAO
    };
    
    <span class="keyword">explicit</span> TabelaEncadeada(<span class="type">size_t</span> tam);
    
    <span class="type">void</span> inserir(<span class="type">int</span> valor, TipoHash tipo);
    <span class="type">bool</span> buscar(<span class="type">int</span> valor, TipoHash tipo) <span class="keyword">const</span>;
    <span class="type">bool</span> remover(<span class="type">int</span> valor, TipoHash tipo);
    
    <span class="type">size_t</span> calcularHashDivisao(<span class="type">int</span> chave) <span class="keyword">const</span>;
    <span class="type">size_t</span> calcularHashMultiplicacao(<span class="type">int</span> chave) <span class="keyword">const</span>;
    
    <span class="type">double</span> fatorCarga() <span class="keyword">const</span>;
    <span class="type">size_t</span> getNumElementos() <span class="keyword">const</span>;
    <span class="type">size_t</span> getTamanho() <span class="keyword">const</span>;
};
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- TabelaAberta.hpp -->
                <article>
                    <details>
                        <summary><code>include/TabelaAberta.hpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Definição da classe <code>TabelaAberta</code>. Utiliza uma estrutura <code>Celula</code> que pode estar em três estados: VAZIO, OCUPADO ou REMOVIDO. A tabela é um único <code>std::vector&lt;Celula&gt;</code>. Implementa sondagem linear para resolução de colisões e controle automático de fator de carga, permitindo lazy deletion para remoções eficientes.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#pragma once</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;optional&gt;</span>
<span class="preprocessor">#include &lt;stdexcept&gt;</span>

<span class="keyword">struct</span> Celula {
    <span class="keyword">enum</span> <span class="keyword">class</span> Estado { 
        VAZIO,
        OCUPADO,
        REMOVIDO
    };
    
    <span class="type">int</span> valor;
    Estado estado;
    
    Celula() : valor(<span class="number">0</span>), estado(Estado::VAZIO) {}
    <span class="keyword">explicit</span> Celula(<span class="type">int</span> val) : valor(val), estado(Estado::OCUPADO) {}
    
    <span class="type">void</span> marcarRemovido();
    <span class="type">bool</span> disponivelParaInsercao() <span class="keyword">const</span>;
};

<span class="keyword">class</span> TabelaAberta {
<span class="keyword">private</span>:
    <span class="type">std::vector&lt;Celula&gt;</span> tabela;
    <span class="type">size_t</span> tamanho;
    <span class="type">size_t</span> numElementos;
    <span class="type">size_t</span> numRemovidos;
    
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> CONSTANTE_MULTIPLICACAO = <span class="number">0.6180339887</span>;
    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> MAX_FATOR_CARGA = <span class="number">0.7</span>;
    
    <span class="type">size_t</span> sondagemLinear(<span class="type">size_t</span> indiceInicial, <span class="type">int</span> valor, <span class="type">bool</span> paraInsercao = <span class="keyword">false</span>) <span class="keyword">const</span>;
    
<span class="keyword">public</span>:
    <span class="keyword">enum</span> <span class="keyword">class</span> TipoHash { 
        DIVISAO,
        MULTIPLICACAO
    };
    
    <span class="keyword">explicit</span> TabelaAberta(<span class="type">size_t</span> tam);
    
    <span class="type">void</span> inserir(<span class="type">int</span> valor, TipoHash tipo);
    <span class="type">bool</span> buscar(<span class="type">int</span> valor, TipoHash tipo) <span class="keyword">const</span>;
    <span class="type">std::optional&lt;int&gt;</span> remover(<span class="type">int</span> valor, TipoHash tipo);
    
    <span class="type">double</span> fatorCarga() <span class="keyword">const</span>;
    <span class="type">bool</span> precisaRehash() <span class="keyword">const</span>;
};
</code></pre></div>
                        </div>
                    </details>
                </article>

                <!-- CarregadorDados.hpp -->
                <article>
                    <details>
                        <summary><code>include/CarregadorDados.hpp</code></summary>
                        <div class="details-content">
                            <p class="text-gray-700 leading-relaxed mb-4">
                                Classe responsável por gerenciar dados para testes de tabelas hash. Sua função principal é <strong>carregar</strong> dados de arquivos existentes na pasta <code>data/</code>, mas também oferece funcionalidades para gerar dados aleatórios para testes adicionais, validar a integridade dos arquivos de dados e fornecer estatísticas sobre os datasets. O nome reflete melhor sua funcionalidade principal de carregamento.
                            </p>
                            <div class="code-block"><pre><code><span class="preprocessor">#pragma once</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;stdexcept&gt;</span>
<span class="preprocessor">#include &lt;random&gt;</span>
<span class="preprocessor">#include &lt;filesystem&gt;</span>

<span class="keyword">class</span> CarregadorDados {
<span class="keyword">private</span>:
    <span class="type">std::mt19937</span> gerador;
    <span class="type">std::uniform_int_distribution&lt;int&gt;</span> distribuicao;
    
    <span class="type">bool</span> arquivoExiste(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
    <span class="type">std::string</span> trim(<span class="keyword">const</span> <span class="type">std::string</span>&amp; str) <span class="keyword">const</span>;

<span class="keyword">public</span>:
    <span class="keyword">explicit</span> CarregadorDados(<span class="type">unsigned</span> <span class="type">int</span> seed = <span class="type">std::random_device</span>{}(), 
                         <span class="type">int</span> minimo = <span class="number">1</span>, 
                         <span class="type">int</span> maximo = <span class="number">1000000</span>);
    
    <span class="comment">/**
     * @brief Carrega números de um arquivo de texto
     * Formato esperado:
     * - Primeira linha: quantidade de números
     * - Linhas seguintes: um número por linha
     */</span>
    <span class="type">std::vector&lt;int&gt;</span> carregarDeArquivo(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
    
    <span class="type">std::vector&lt;int&gt;</span> gerarNumerosAleatorios(<span class="type">size_t</span> quantidade);
    <span class="type">std::vector&lt;int&gt;</span> gerarNumerosAleatoriosComRepeticao(<span class="type">size_t</span> quantidade);
    
    <span class="type">bool</span> salvarEmArquivo(<span class="keyword">const</span> <span class="type">std::vector&lt;int&gt;</span>&amp; numeros, <span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo);
    <span class="type">bool</span> validarArquivo(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
    
    <span class="type">std::vector&lt;std::string&gt;</span> listarArquivosDisponiveis() <span class="keyword">const</span>;
    <span class="type">void</span> exibirEstatisticas(<span class="keyword">const</span> <span class="type">std::string</span>&amp; nomeArquivo) <span class="keyword">const</span>;
};
</code></pre></div>
                        </div>
                    </details>
                </article>
            </div>
        </section>

        <!-- Resultados e Gráficos -->
        <section id="graficos" class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">4. Resultados e Gráficos</h2>
            <p class="mb-6 text-gray-700">
                Os gráficos abaixo apresentam uma análise visual do desempenho das diferentes implementações de tabela hash. Use os filtros para comparar os cenários e clique no botão para baixar uma imagem do gráfico.
            </p>

            <!-- Controles do Gráfico -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 p-4 bg-gray-50 rounded-lg border">
                <div>
                    <label for="chartType" class="block text-sm font-medium text-gray-700">Métrica de Análise:</label>
                    <select id="chartType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="insertion" selected>Tempo de Inserção (ms)</option>
                        <option value="search">Tempo de Busca (ms)</option>
                        <option value="collisions">Colisões</option>
                    </select>
                </div>
                <div>
                    <label for="tableType" class="block text-sm font-medium text-gray-700">Tipo de Tabela Hash:</label>
                    <select id="tableType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Encadeada">Encadeada</option>
                        <option value="Aberta">Aberta</option>
                    </select>
                </div>
                 <div>
                    <label for="hashFunction" class="block text-sm font-medium text-gray-700">Função de Hash:</label>
                    <select id="hashFunction" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all" selected>Ambas (Comparativo)</option>
                        <option value="Divisao">Divisão</option>
                        <option value="Multiplicacao">Multiplicação</option>
                    </select>
                </div>
            </div>

            <!-- Container do Gráfico -->
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
            <div class="text-center mt-4">
                <button id="downloadChartBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-300">
                    Baixar Gráfico
                </button>
            </div>
        </section>

         <!-- Conclusão -->
        <section id="conclusao" class="mt-12 bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">5. Conclusão</h2>
            <p class="text-gray-700 leading-relaxed">
                A análise comparativa revelou insights importantes sobre o comportamento das diferentes estratégias de hashing. A <strong>TabelaEncadeada</strong> demonstrou ser mais robusta e previsível, especialmente em cenários com alto fator de carga, onde o desempenho de inserção e busca degrada de forma mais suave. Embora possa consumir mais memória devido às listas, sua performance é menos sensível à qualidade da função de hash.
            </p>
            <p class="text-gray-700 leading-relaxed mt-4">
                Por outro lado, a <strong>TabelaAberta</strong> se mostrou extremamente eficiente em cenários de baixo fator de carga, superando a versão encadeada devido à melhor localidade de cache e menor sobrecarga de alocação de memória. No entanto, seu desempenho decai drasticamente à medida que a tabela se aproxima de sua capacidade máxima, tornando-a inadequada para cenários onde o número de elementos é próximo ao tamanho da tabela.
            </p>
             <p class="text-gray-700 leading-relaxed mt-4">
                Entre as funções de hash, não houve um vencedor claro em todos os cenários, mas a função de <strong>divisão</strong> apresentou, em média, uma distribuição ligeiramente melhor e menos colisões, principalmente para a tabela de endereçamento aberto. A escolha da abordagem ideal depende, portanto, dos requisitos específicos da aplicação, como a previsibilidade do número de elementos, as restrições de memória e a performance desejada.
            </p>
        </section>

    </main>

    <footer class="bg-white mt-12">
        <div class="container mx-auto px-6 py-4 text-center text-gray-500">
            <p>Desenvolvido para a disciplina de Pesquisa e Ordenação.</p>
        </div>
    </footer>

    <script>
        // Data from resultados_benchmark.csv
        const csvData = `TipoTabela,TamanhoTabela,QuantidadeDados,FuncaoHash,TempoInsercao(ms),TempoBusca(ms),Colisoes,FatorCarga
Encadeada,29,100,Divisao,0.010,0.018,71,3.4483
Encadeada,29,100,Multiplicacao,0.009,0.028,71,3.4483
Encadeada,97,100,Divisao,0.008,0.014,37,1.0309
Encadeada,97,100,Multiplicacao,0.008,0.023,37,1.0309
Encadeada,251,100,Divisao,0.006,0.014,0,0.3984
Encadeada,251,100,Multiplicacao,0.005,0.013,0,0.3984
Encadeada,499,100,Divisao,0.009,0.007,0,0.2004
Encadeada,499,100,Multiplicacao,0.006,0.012,0,0.2004
Encadeada,911,100,Divisao,0.007,0.005,0,0.1098
Encadeada,911,100,Multiplicacao,0.007,0.006,0,0.1098
Aberta,101,100,Divisao,0.007,0.004,50,0.9901
Aberta,101,100,Multiplicacao,0.007,0.004,50,0.9901
Aberta,251,100,Divisao,0.005,0.003,0,0.3984
Aberta,251,100,Multiplicacao,0.006,0.003,0,0.3984
Aberta,499,100,Divisao,0.006,0.002,0,0.2004
Aberta,499,100,Multiplicacao,0.006,0.003,0,0.2004
Aberta,911,100,Divisao,0.006,0.003,0,0.1098
Aberta,911,100,Multiplicacao,0.006,0.003,0,0.1098
Encadeada,29,500,Divisao,0.100,0.279,471,17.2414
Encadeada,29,500,Multiplicacao,0.086,0.258,471,17.2414
Encadeada,97,500,Divisao,0.049,0.119,403,5.1546
Encadeada,97,500,Multiplicacao,0.053,0.103,403,5.1546
Encadeada,251,500,Divisao,0.035,0.057,249,1.9920
Encadeada,251,500,Multiplicacao,0.037,0.051,249,1.9920
Encadeada,499,500,Divisao,0.030,0.024,1,0.0020
Encadeada,499,500,Multiplicacao,0.031,0.027,1,0.0020
Encadeada,911,500,Divisao,0.028,0.015,0,0.5488
Encadeada,911,500,Multiplicacao,0.028,0.019,0,0.5488
Aberta,503,500,Divisao,0.031,0.015,249,0.9940
Aberta,503,500,Multiplicacao,0.032,0.015,249,0.9940
Aberta,911,500,Divisao,0.028,0.012,0,0.5488
Aberta,911,500,Multiplicacao,0.029,0.014,0,0.5488
Encadeada,29,1000,Divisao,0.284,0.767,971,34.4828
Encadeada,29,1000,Multiplicacao,0.297,0.911,971,34.4828
Encadeada,97,1000,Divisao,0.119,0.287,903,10.3093
Encadeada,97,1000,Multiplicacao,0.115,0.263,903,10.3093
Encadeada,251,1000,Divisao,0.076,0.123,749,3.9841
Encadeada,251,1000,Multiplicacao,0.076,0.111,749,3.9841
Encadeada,499,1000,Divisao,0.063,0.059,501,2.0040
Encadeada,499,1000,Multiplicacao,0.066,0.060,501,2.0040
Encadeada,911,1000,Divisao,0.058,0.032,89,1.0977
Encadeada,911,1000,Multiplicacao,0.057,0.035,89,1.0977
Aberta,1009,1000,Divisao,0.057,0.028,496,0.9911
Aberta,1009,1000,Multiplicacao,0.062,0.030,496,0.9911
Encadeada,29,5000,Divisao,4.329,8.514,4971,172.4138
Encadeada,29,5000,Multiplicacao,4.551,9.088,4971,172.4138
Encadeada,97,5000,Divisao,1.442,3.159,4903,51.5464
Encadeada,97,5000,Multiplicacao,1.558,3.226,4903,51.5464
Encadeada,251,5000,Divisao,0.592,1.011,4750,19.9203
Encadeada,251,5000,Multiplicacao,0.594,0.932,4750,19.9203
Encadeada,499,5000,Divisao,0.379,0.510,4501,10.0200
Encadeada,499,5000,Multiplicacao,0.395,0.479,4501,10.0200
Encadeada,911,5000,Divisao,0.292,0.252,4089,5.4885
Encadeada,911,5000,Multiplicacao,0.291,0.254,4089,5.4885
Aberta,5003,5000,Divisao,0.290,0.141,2493,0.9994
Aberta,5003,5000,Multiplicacao,0.312,0.155,2493,0.9994
Encadeada,29,10000,Divisao,10.647,1.779,9922,343.1379
Encadeada,29,10000,Multiplicacao,9.404,1.932,9922,343.1379
Encadeada,97,10000,Divisao,3.794,1.424,9854,102.5876
Encadeada,97,10000,Multiplicacao,3.483,0.541,9854,102.5876
Encadeada,251,10000,Divisao,1.358,0.195,9700,39.6454
Encadeada,251,10000,Multiplicacao,1.445,0.205,9700,39.6454
Encadeada,499,10000,Divisao,0.896,0.103,9500,20.0401
Encadeada,499,10000,Multiplicacao,0.875,0.102,9500,20.0401
Encadeada,911,10000,Divisao,0.618,0.061,9088,10.9769
Encadeada,911,10000,Multiplicacao,0.609,0.060,9088,10.9769
Aberta,10007,10000,Divisao,0.612,0.303,4992,0.9993
Aberta,10007,10000,Multiplicacao,0.627,0.320,4992,0.9993
Encadeada,29,50000,Divisao,315.341,833.111,49971,1724.1379
Encadeada,29,50000,Multiplicacao,305.981,852.179,49971,1724.1379
Encadeada,97,50000,Divisao,93.992,260.912,49903,515.4639
Encadeada,97,50000,Multiplicacao,97.388,272.871,49903,515.4639
Encadeada,251,50000,Divisao,36.561,91.879,49750,199.2032
Encadeada,251,50000,Multiplicacao,37.330,96.678,49750,199.2032
Encadeada,499,50000,Divisao,21.841,50.111,49501,100.2004
Encadeada,499,50000,Multiplicacao,22.251,52.288,49501,100.2004
Encadeada,911,50000,Divisao,13.790,29.332,49089,54.8847
Encadeada,911,50000,Multiplicacao,13.679,28.690,49089,54.8847
Aberta,50021,50000,Divisao,15.223,7.568,24982,0.9996
Aberta,50021,50000,Multiplicacao,15.178,7.741,24982,0.9996`;

        function parseCSV(data) {
            const lines = data.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const entry = {};
                headers.forEach((header, i) => {
                    const value = values[i];
                    entry[header] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                });
                return entry;
            });
        }

        const benchmarkData = parseCSV(csvData);
        let myChart;

        const chartConfig = {
            insertion: {
                label: 'Tempo de Inserção (ms)',
                key: 'TempoInsercao(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            search: {
                label: 'Tempo de Busca (ms)',
                key: 'TempoBusca(ms)',
                yAxisLabel: 'Tempo (ms)'
            },
            collisions: {
                label: 'Colisões',
                key: 'Colisoes',
                yAxisLabel: 'Número de Colisões'
            }
        };

        const colors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };
         const borderColors = {
            'Encadeada-Divisao': 'rgba(54, 162, 235, 1)',
            'Encadeada-Multiplicacao': 'rgba(255, 99, 132, 1)',
            'Aberta-Divisao': 'rgba(75, 192, 192, 1)',
            'Aberta-Multiplicacao': 'rgba(255, 206, 86, 1)',
        };


        function updateChart() {
            const chartType = document.getElementById('chartType').value;
            const tableType = document.getElementById('tableType').value;
            const hashFunction = document.getElementById('hashFunction').value;

            const selectedConfig = chartConfig[chartType];

            let filteredData = benchmarkData;
            if (tableType !== 'all') {
                filteredData = filteredData.filter(d => d.TipoTabela === tableType);
            }
            if (hashFunction !== 'all') {
                filteredData = filteredData.filter(d => d.FuncaoHash === hashFunction);
            }
            
            const labels = [...new Set(filteredData.map(d => d.QuantidadeDados))].sort((a,b) => a - b);

            const datasets = [];
            const combinations = [...new Set(filteredData.map(d => `${d.TipoTabela}-${d.FuncaoHash}`))];

            combinations.forEach(combo => {
                const [tipo, hash] = combo.split('-');
                
                const dataForCombo = filteredData.filter(d => d.TipoTabela === tipo && d.FuncaoHash === hash);
                
                // Agrupar por QuantidadeDados e pegar a média para evitar multiplos pontos
                const dataPoints = labels.map(label => {
                    const points = dataForCombo
                        .filter(d => d.QuantidadeDados === label)
                        .map(d => d[selectedConfig.key]);
                    return points.length > 0 ? points.reduce((a, b) => a + b, 0) / points.length : null;
                });
                
                datasets.push({
                    label: `${tipo} - ${hash}`,
                    data: dataPoints,
                    borderColor: borderColors[combo],
                    backgroundColor: colors[combo].replace('1)', '0.2)'),
                    fill: false,
                    tension: 0.1
                });
            });


            const ctx = document.getElementById('benchmarkChart').getContext('2d');
            if (myChart) {
                myChart.destroy();
            }
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectedConfig.label} vs. Quantidade de Dados`,
                            font: { size: 18 }
                        },
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Quantidade de Dados Inseridos'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: selectedConfig.yAxisLabel
                            },
                             type: 'logarithmic',
                             ticks: {
                                callback: function(value, index, values) {
                                    if (value >= 1000) {
                                        return value.toExponential();
                                    }
                                    return Number(value.toString());
                                }
                            }
                        }
                    }
                }
            });
        }

        document.getElementById('chartType').addEventListener('change', updateChart);
        document.getElementById('tableType').addEventListener('change', updateChart);
        document.getElementById('hashFunction').addEventListener('change', updateChart);
        
        document.getElementById('downloadChartBtn').addEventListener('click', () => {
            const chartCanvas = document.getElementById('benchmarkChart');
            const url = chartCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = url;
            link.download = `grafico_benchmark_${new Date().getTime()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initial chart render
        window.addEventListener('load', updateChart);

    </script>
</body>
</html>